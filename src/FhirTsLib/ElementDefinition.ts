import { Type } from 'class-transformer';
import { REGEX_ID, REGEX_PATH, REGEX_SLICENAME, REGEX_LABEL, REGEX_SHORT, REGEX_DEFINITION, REGEX_COMMENT, REGEX_REQUIREMENTS, REGEX_MAX, REGEX_CONTENTREFERENCE, REGEX_DEFAULTVALUEBASE64BINARY, REGEX_DEFAULTVALUECANONICAL, REGEX_DEFAULTVALUECODE, REGEX_DEFAULTVALUEDATE, REGEX_DEFAULTVALUEDATETIME, REGEX_DEFAULTVALUEID, REGEX_DEFAULTVALUEINSTANT, REGEX_DEFAULTVALUEMARKDOWN, REGEX_DEFAULTVALUEOID, REGEX_DEFAULTVALUESTRING, REGEX_DEFAULTVALUETIME, REGEX_DEFAULTVALUEURI, REGEX_DEFAULTVALUEURL, REGEX_DEFAULTVALUEUUID, REGEX_MEANINGWHENMISSING, REGEX_ORDERMEANING, REGEX_FIXEDBASE64BINARY, REGEX_FIXEDCANONICAL, REGEX_FIXEDCODE, REGEX_FIXEDDATE, REGEX_FIXEDDATETIME, REGEX_FIXEDID, REGEX_FIXEDINSTANT, REGEX_FIXEDMARKDOWN, REGEX_FIXEDOID, REGEX_FIXEDSTRING, REGEX_FIXEDTIME, REGEX_FIXEDURI, REGEX_FIXEDURL, REGEX_FIXEDUUID, REGEX_PATTERNBASE64BINARY, REGEX_PATTERNCANONICAL, REGEX_PATTERNCODE, REGEX_PATTERNDATE, REGEX_PATTERNDATETIME, REGEX_PATTERNID, REGEX_PATTERNINSTANT, REGEX_PATTERNMARKDOWN, REGEX_PATTERNOID, REGEX_PATTERNSTRING, REGEX_PATTERNTIME, REGEX_PATTERNURI, REGEX_PATTERNURL, REGEX_PATTERNUUID, REGEX_MINVALUEDATE, REGEX_MINVALUEDATETIME, REGEX_MINVALUEINSTANT, REGEX_MINVALUETIME, REGEX_MAXVALUEDATE, REGEX_MAXVALUEDATETIME, REGEX_MAXVALUEINSTANT, REGEX_MAXVALUETIME, REGEX_ISMODIFIERREASON } from '../FhirTsLibValidation/FhirRegex';
import { Address, Age, Annotation, Attachment, CodeableConcept, Coding, ContactDetail, ContactPoint, Contributor, Count, DataRequirement, Distance, Dosage, Duration, Element, ElementDefinitionBase, ElementDefinitionBinding, ElementDefinitionConstraint, ElementDefinitionExample, ElementDefinitionMapping, ElementDefinitionSlicing, ElementDefinitionType, Expression, Extension, HumanName, Identifier, Meta, Money, ParameterDefinition, Period, Quantity, Range, Ratio, Reference, RelatedArtifact, SampledData, Signature, Timing, TriggerDefinition, UsageContext } from './FhirType';



/**
 * Captures constraints on each element within the resource, profile, or extension.
 *
 * Generated by Gallaware, Inc. from:
 *    file:/Users/admin/Documents/DevNetbeans/jsonSchemaToJava/target/classes/schema/fhir.schema.json#/definitions/ElementDefinition
 */
export class ElementDefinition {
  /**
   * A sequence of Unicode characters
   * Field access restricted because there are specific valid values.
   */
  protected id?: string;

  /**
   * May be used to represent additional information that is not part of the basic definition of the
   * element. To make the use of extensions safe and manageable, there is a strict set of governance
   * applied to the definition and use of extensions. Though any implementer can define an extension,
   * there is a set of requirements that SHALL be met as part of the definition of the extension.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Extension)
  protected extension?: Extension[];

  /**
   * May be used to represent additional information that is not part of the basic definition of the
   * element and that modifies the understanding of the element in which it is contained and/or the
   * understanding of the containing element's descendants. Usually modifier elements provide negation
   * or qualification. To make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any implementer can define an
   * extension, there is a set of requirements that SHALL be met as part of the definition of the
   * extension. Applications processing a resource are required to check for modifier extensions.
   * 
   * Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Extension)
  protected modifierExtension?: Extension[];

  /**
   * A sequence of Unicode characters
   * Field access restricted because there are specific valid values.
   */
  protected path?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _path?: Element;

  /**
   * Codes that define how this element is represented in instances, when the deviation varies from the
   * normal case.
   * Field access restricted because there are specific valid values.
   */
  protected representation?: string[];

  /**
   * Extensions for representation
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Element)
  protected _representation?: Element[];

  /**
   * A sequence of Unicode characters
   * Field access restricted because there are specific valid values.
   */
  protected sliceName?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _sliceName?: Element;

  /**
   * Value of "true" or "false"
   */
   sliceIsConstraining?: boolean;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _sliceIsConstraining?: Element;

  /**
   * A sequence of Unicode characters
   * Field access restricted because there are specific valid values.
   */
  protected label?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _label?: Element;

  /**
   * A code that has the same meaning as the element in a particular terminology.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Coding)
  protected code?: Coding[];

  /**
   * Captures constraints on each element within the resource, profile, or extension.
   */
  @Type(() => ElementDefinitionSlicing)
   slicing?: ElementDefinitionSlicing;

  /**
   * A sequence of Unicode characters
   * Field access restricted because there are specific valid values.
   */
  protected short?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _short?: Element;

  /**
   * A string that may contain Github Flavored Markdown syntax for optional processing by a mark down
   * presentation engine
   * Field access restricted because there are specific valid values.
   */
  protected definition?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _definition?: Element;

  /**
   * A string that may contain Github Flavored Markdown syntax for optional processing by a mark down
   * presentation engine
   * Field access restricted because there are specific valid values.
   */
  protected comment?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _comment?: Element;

  /**
   * A string that may contain Github Flavored Markdown syntax for optional processing by a mark down
   * presentation engine
   * Field access restricted because there are specific valid values.
   */
  protected requirements?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _requirements?: Element;

  /**
   * Identifies additional names by which this element might also be known.
   * Field access restricted because there are specific valid values.
   */
  protected alias?: string[];

  /**
   * Extensions for alias
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Element)
  protected _alias?: Element[];

  /**
   * An integer with a value that is not negative (e.g. >= 0)
   */
   min?: number;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _min?: Element;

  /**
   * A sequence of Unicode characters
   * Field access restricted because there are specific valid values.
   */
  protected max?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _max?: Element;

  /**
   * Captures constraints on each element within the resource, profile, or extension.
   */
  @Type(() => ElementDefinitionBase)
   base?: ElementDefinitionBase;

  /**
   * String of characters used to identify a name or a resource
   * Field access restricted because there are specific valid values.
   */
  protected contentReference?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _contentReference?: Element;

  /**
   * The data type or resource that the value of this element is permitted to be.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => ElementDefinitionType)
  protected type?: ElementDefinitionType[];

  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise
   * specified, the abstract is false').
   * Field access restricted because there are specific valid values.
   */
  protected defaultValueBase64Binary?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _defaultValueBase64Binary?: Element;

  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise
   * specified, the abstract is false').
   */
   defaultValueBoolean?: boolean;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _defaultValueBoolean?: Element;

  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise
   * specified, the abstract is false').
   * Field access restricted because there are specific valid values.
   */
  protected defaultValueCanonical?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _defaultValueCanonical?: Element;

  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise
   * specified, the abstract is false').
   * Field access restricted because there are specific valid values.
   */
  protected defaultValueCode?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _defaultValueCode?: Element;

  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise
   * specified, the abstract is false').
   * Field access restricted because there are specific valid values.
   */
  protected defaultValueDate?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _defaultValueDate?: Element;

  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise
   * specified, the abstract is false').
   * Field access restricted because there are specific valid values.
   */
  protected defaultValueDateTime?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _defaultValueDateTime?: Element;

  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise
   * specified, the abstract is false').
   */
   defaultValueDecimal?: number;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _defaultValueDecimal?: Element;

  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise
   * specified, the abstract is false').
   * Field access restricted because there are specific valid values.
   */
  protected defaultValueId?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _defaultValueId?: Element;

  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise
   * specified, the abstract is false').
   * Field access restricted because there are specific valid values.
   */
  protected defaultValueInstant?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _defaultValueInstant?: Element;

  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise
   * specified, the abstract is false').
   */
   defaultValueInteger?: number;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _defaultValueInteger?: Element;

  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise
   * specified, the abstract is false').
   * Field access restricted because there are specific valid values.
   */
  protected defaultValueMarkdown?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _defaultValueMarkdown?: Element;

  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise
   * specified, the abstract is false').
   * Field access restricted because there are specific valid values.
   */
  protected defaultValueOid?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _defaultValueOid?: Element;

  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise
   * specified, the abstract is false').
   */
   defaultValuePositiveInt?: number;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _defaultValuePositiveInt?: Element;

  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise
   * specified, the abstract is false').
   * Field access restricted because there are specific valid values.
   */
  protected defaultValueString?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _defaultValueString?: Element;

  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise
   * specified, the abstract is false').
   * Field access restricted because there are specific valid values.
   */
  protected defaultValueTime?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _defaultValueTime?: Element;

  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise
   * specified, the abstract is false').
   */
   defaultValueUnsignedInt?: number;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _defaultValueUnsignedInt?: Element;

  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise
   * specified, the abstract is false').
   * Field access restricted because there are specific valid values.
   */
  protected defaultValueUri?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _defaultValueUri?: Element;

  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise
   * specified, the abstract is false').
   * Field access restricted because there are specific valid values.
   */
  protected defaultValueUrl?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _defaultValueUrl?: Element;

  /**
   * The value that should be used if there is no value stated in the instance (e.g. 'if not otherwise
   * specified, the abstract is false').
   * Field access restricted because there are specific valid values.
   */
  protected defaultValueUuid?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _defaultValueUuid?: Element;

  /**
   * An address expressed using postal conventions (as opposed to GPS or other location definition
   * formats).  This data type may be used to convey addresses for use in delivering mail as well as
   * for visiting locations which might not be valid for mail delivery.  There are a variety of postal
   * address formats defined around the world.
   */
  @Type(() => Address)
   defaultValueAddress?: Address;

  /**
   * A duration of time during which an organism (or a process) has existed.
   */
  @Type(() => Age)
   defaultValueAge?: Age;

  /**
   * A  text note which also  contains information about who made the statement and when.
   */
  @Type(() => Annotation)
   defaultValueAnnotation?: Annotation;

  /**
   * For referring to data content defined in other formats.
   */
  @Type(() => Attachment)
   defaultValueAttachment?: Attachment;

  /**
   * A concept that may be defined by a formal reference to a terminology or ontology or may be provided
   * by text.
   */
  @Type(() => CodeableConcept)
   defaultValueCodeableConcept?: CodeableConcept;

  /**
   * A reference to a code defined by a terminology system.
   */
  @Type(() => Coding)
   defaultValueCoding?: Coding;

  /**
   * Details for all kinds of technology mediated contact points for a person or organization, including
   * telephone, email, etc.
   */
  @Type(() => ContactPoint)
   defaultValueContactPoint?: ContactPoint;

  /**
   * A measured amount (or an amount that can potentially be measured). Note that measured amounts
   * include amounts that are not precisely quantified, including amounts involving arbitrary units and
   * floating currencies.
   */
  @Type(() => Count)
   defaultValueCount?: Count;

  /**
   * A length - a value with a unit that is a physical distance.
   */
  @Type(() => Distance)
   defaultValueDistance?: Distance;

  /**
   * A length of time.
   */
  @Type(() => Duration)
   defaultValueDuration?: Duration;

  /**
   * A human's name with the ability to identify parts and usage.
   */
  @Type(() => HumanName)
   defaultValueHumanName?: HumanName;

  /**
   * An identifier - identifies some entity uniquely and unambiguously. Typically this is used for
   * business identifiers.
   */
  @Type(() => Identifier)
   defaultValueIdentifier?: Identifier;

  /**
   * An amount of economic utility in some recognized currency.
   */
  @Type(() => Money)
   defaultValueMoney?: Money;

  /**
   * A time period defined by a start and end date and optionally time.
   */
  @Type(() => Period)
   defaultValuePeriod?: Period;

  /**
   * A measured amount (or an amount that can potentially be measured). Note that measured amounts
   * include amounts that are not precisely quantified, including amounts involving arbitrary units and
   * floating currencies.
   */
  @Type(() => Quantity)
   defaultValueQuantity?: Quantity;

  /**
   * A set of ordered Quantities defined by a low and high limit.
   */
  @Type(() => Range)
   defaultValueRange?: Range;

  /**
   * A relationship of two Quantity values - expressed as a numerator and a denominator.
   */
  @Type(() => Ratio)
   defaultValueRatio?: Ratio;

  /**
   * A reference from one resource to another.
   */
  @Type(() => Reference)
   defaultValueReference?: Reference;

  /**
   * A series of measurements taken by a device, with upper and lower limits. There may be more than one
   * dimension in the data.
   */
  @Type(() => SampledData)
   defaultValueSampledData?: SampledData;

  /**
   * A signature along with supporting context. The signature may be a digital signature that is
   * cryptographic in nature, or some other signature acceptable to the domain. This other signature
   * may be as simple as a graphical image representing a hand-written signature, or a signature
   * ceremony Different signature approaches have different utilities.
   */
  @Type(() => Signature)
   defaultValueSignature?: Signature;

  /**
   * Specifies an event that may occur multiple times. Timing schedules are used to record when things
   * are planned, expected or requested to occur. The most common usage is in dosage instructions for
   * medications. They are also used when planning care of various kinds, and may be used for reporting
   * the schedule to which past regular activities were carried out.
   */
  @Type(() => Timing)
   defaultValueTiming?: Timing;

  /**
   * Specifies contact information for a person or organization.
   */
  @Type(() => ContactDetail)
   defaultValueContactDetail?: ContactDetail;

  /**
   * A contributor to the content of a knowledge asset, including authors, editors, reviewers, and
   * endorsers.
   */
  @Type(() => Contributor)
   defaultValueContributor?: Contributor;

  /**
   * Describes a required data item for evaluation in terms of the type of data, and optional code or
   * date-based filters of the data.
   */
  @Type(() => DataRequirement)
   defaultValueDataRequirement?: DataRequirement;

  /**
   * A expression that is evaluated in a specified context and returns a value. The context of use of
   * the expression must specify the context in which the expression is evaluated, and how the result
   * of the expression is used.
   */
  @Type(() => Expression)
   defaultValueExpression?: Expression;

  /**
   * The parameters to the module. This collection specifies both the input and output parameters. Input
   * parameters are provided by the caller as part of the $evaluate operation. Output parameters are
   * included in the GuidanceResponse.
   */
  @Type(() => ParameterDefinition)
   defaultValueParameterDefinition?: ParameterDefinition;

  /**
   * Related artifacts such as additional documentation, justification, or bibliographic references.
   */
  @Type(() => RelatedArtifact)
   defaultValueRelatedArtifact?: RelatedArtifact;

  /**
   * A description of a triggering event. Triggering events can be named events, data events, or
   * periodic, as determined by the type element.
   */
  @Type(() => TriggerDefinition)
   defaultValueTriggerDefinition?: TriggerDefinition;

  /**
   * Specifies clinical/business/etc. metadata that can be used to retrieve, index and/or categorize an
   * artifact. This metadata can either be specific to the applicable population (e.g., age category,
   * DRG) or the specific context of care (e.g., venue, care setting, provider of care).
   */
  @Type(() => UsageContext)
   defaultValueUsageContext?: UsageContext;

  /**
   * Indicates how the medication is/was taken or should be taken by the patient.
   */
  @Type(() => Dosage)
   defaultValueDosage?: Dosage;

  /**
   * The metadata about a resource. This is content in the resource that is maintained by the
   * infrastructure. Changes to the content might not always be associated with version changes to the
   * resource.
   */
  @Type(() => Meta)
   defaultValueMeta?: Meta;

  /**
   * A string that may contain Github Flavored Markdown syntax for optional processing by a mark down
   * presentation engine
   * Field access restricted because there are specific valid values.
   */
  protected meaningWhenMissing?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _meaningWhenMissing?: Element;

  /**
   * A sequence of Unicode characters
   * Field access restricted because there are specific valid values.
   */
  protected orderMeaning?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _orderMeaning?: Element;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes
   * of comparison, non-significant whitespace is ignored, and all values must be an exact match (case
   * and accent sensitive). Missing elements/attributes must also be missing.
   * Field access restricted because there are specific valid values.
   */
  protected fixedBase64Binary?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _fixedBase64Binary?: Element;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes
   * of comparison, non-significant whitespace is ignored, and all values must be an exact match (case
   * and accent sensitive). Missing elements/attributes must also be missing.
   */
   fixedBoolean?: boolean;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _fixedBoolean?: Element;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes
   * of comparison, non-significant whitespace is ignored, and all values must be an exact match (case
   * and accent sensitive). Missing elements/attributes must also be missing.
   * Field access restricted because there are specific valid values.
   */
  protected fixedCanonical?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _fixedCanonical?: Element;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes
   * of comparison, non-significant whitespace is ignored, and all values must be an exact match (case
   * and accent sensitive). Missing elements/attributes must also be missing.
   * Field access restricted because there are specific valid values.
   */
  protected fixedCode?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _fixedCode?: Element;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes
   * of comparison, non-significant whitespace is ignored, and all values must be an exact match (case
   * and accent sensitive). Missing elements/attributes must also be missing.
   * Field access restricted because there are specific valid values.
   */
  protected fixedDate?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _fixedDate?: Element;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes
   * of comparison, non-significant whitespace is ignored, and all values must be an exact match (case
   * and accent sensitive). Missing elements/attributes must also be missing.
   * Field access restricted because there are specific valid values.
   */
  protected fixedDateTime?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _fixedDateTime?: Element;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes
   * of comparison, non-significant whitespace is ignored, and all values must be an exact match (case
   * and accent sensitive). Missing elements/attributes must also be missing.
   */
   fixedDecimal?: number;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _fixedDecimal?: Element;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes
   * of comparison, non-significant whitespace is ignored, and all values must be an exact match (case
   * and accent sensitive). Missing elements/attributes must also be missing.
   * Field access restricted because there are specific valid values.
   */
  protected fixedId?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _fixedId?: Element;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes
   * of comparison, non-significant whitespace is ignored, and all values must be an exact match (case
   * and accent sensitive). Missing elements/attributes must also be missing.
   * Field access restricted because there are specific valid values.
   */
  protected fixedInstant?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _fixedInstant?: Element;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes
   * of comparison, non-significant whitespace is ignored, and all values must be an exact match (case
   * and accent sensitive). Missing elements/attributes must also be missing.
   */
   fixedInteger?: number;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _fixedInteger?: Element;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes
   * of comparison, non-significant whitespace is ignored, and all values must be an exact match (case
   * and accent sensitive). Missing elements/attributes must also be missing.
   * Field access restricted because there are specific valid values.
   */
  protected fixedMarkdown?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _fixedMarkdown?: Element;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes
   * of comparison, non-significant whitespace is ignored, and all values must be an exact match (case
   * and accent sensitive). Missing elements/attributes must also be missing.
   * Field access restricted because there are specific valid values.
   */
  protected fixedOid?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _fixedOid?: Element;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes
   * of comparison, non-significant whitespace is ignored, and all values must be an exact match (case
   * and accent sensitive). Missing elements/attributes must also be missing.
   */
   fixedPositiveInt?: number;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _fixedPositiveInt?: Element;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes
   * of comparison, non-significant whitespace is ignored, and all values must be an exact match (case
   * and accent sensitive). Missing elements/attributes must also be missing.
   * Field access restricted because there are specific valid values.
   */
  protected fixedString?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _fixedString?: Element;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes
   * of comparison, non-significant whitespace is ignored, and all values must be an exact match (case
   * and accent sensitive). Missing elements/attributes must also be missing.
   * Field access restricted because there are specific valid values.
   */
  protected fixedTime?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _fixedTime?: Element;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes
   * of comparison, non-significant whitespace is ignored, and all values must be an exact match (case
   * and accent sensitive). Missing elements/attributes must also be missing.
   */
   fixedUnsignedInt?: number;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _fixedUnsignedInt?: Element;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes
   * of comparison, non-significant whitespace is ignored, and all values must be an exact match (case
   * and accent sensitive). Missing elements/attributes must also be missing.
   * Field access restricted because there are specific valid values.
   */
  protected fixedUri?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _fixedUri?: Element;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes
   * of comparison, non-significant whitespace is ignored, and all values must be an exact match (case
   * and accent sensitive). Missing elements/attributes must also be missing.
   * Field access restricted because there are specific valid values.
   */
  protected fixedUrl?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _fixedUrl?: Element;

  /**
   * Specifies a value that SHALL be exactly the value  for this element in the instance. For purposes
   * of comparison, non-significant whitespace is ignored, and all values must be an exact match (case
   * and accent sensitive). Missing elements/attributes must also be missing.
   * Field access restricted because there are specific valid values.
   */
  protected fixedUuid?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _fixedUuid?: Element;

  /**
   * An address expressed using postal conventions (as opposed to GPS or other location definition
   * formats).  This data type may be used to convey addresses for use in delivering mail as well as
   * for visiting locations which might not be valid for mail delivery.  There are a variety of postal
   * address formats defined around the world.
   */
  @Type(() => Address)
   fixedAddress?: Address;

  /**
   * A duration of time during which an organism (or a process) has existed.
   */
  @Type(() => Age)
   fixedAge?: Age;

  /**
   * A  text note which also  contains information about who made the statement and when.
   */
  @Type(() => Annotation)
   fixedAnnotation?: Annotation;

  /**
   * For referring to data content defined in other formats.
   */
  @Type(() => Attachment)
   fixedAttachment?: Attachment;

  /**
   * A concept that may be defined by a formal reference to a terminology or ontology or may be provided
   * by text.
   */
  @Type(() => CodeableConcept)
   fixedCodeableConcept?: CodeableConcept;

  /**
   * A reference to a code defined by a terminology system.
   */
  @Type(() => Coding)
   fixedCoding?: Coding;

  /**
   * Details for all kinds of technology mediated contact points for a person or organization, including
   * telephone, email, etc.
   */
  @Type(() => ContactPoint)
   fixedContactPoint?: ContactPoint;

  /**
   * A measured amount (or an amount that can potentially be measured). Note that measured amounts
   * include amounts that are not precisely quantified, including amounts involving arbitrary units and
   * floating currencies.
   */
  @Type(() => Count)
   fixedCount?: Count;

  /**
   * A length - a value with a unit that is a physical distance.
   */
  @Type(() => Distance)
   fixedDistance?: Distance;

  /**
   * A length of time.
   */
  @Type(() => Duration)
   fixedDuration?: Duration;

  /**
   * A human's name with the ability to identify parts and usage.
   */
  @Type(() => HumanName)
   fixedHumanName?: HumanName;

  /**
   * An identifier - identifies some entity uniquely and unambiguously. Typically this is used for
   * business identifiers.
   */
  @Type(() => Identifier)
   fixedIdentifier?: Identifier;

  /**
   * An amount of economic utility in some recognized currency.
   */
  @Type(() => Money)
   fixedMoney?: Money;

  /**
   * A time period defined by a start and end date and optionally time.
   */
  @Type(() => Period)
   fixedPeriod?: Period;

  /**
   * A measured amount (or an amount that can potentially be measured). Note that measured amounts
   * include amounts that are not precisely quantified, including amounts involving arbitrary units and
   * floating currencies.
   */
  @Type(() => Quantity)
   fixedQuantity?: Quantity;

  /**
   * A set of ordered Quantities defined by a low and high limit.
   */
  @Type(() => Range)
   fixedRange?: Range;

  /**
   * A relationship of two Quantity values - expressed as a numerator and a denominator.
   */
  @Type(() => Ratio)
   fixedRatio?: Ratio;

  /**
   * A reference from one resource to another.
   */
  @Type(() => Reference)
   fixedReference?: Reference;

  /**
   * A series of measurements taken by a device, with upper and lower limits. There may be more than one
   * dimension in the data.
   */
  @Type(() => SampledData)
   fixedSampledData?: SampledData;

  /**
   * A signature along with supporting context. The signature may be a digital signature that is
   * cryptographic in nature, or some other signature acceptable to the domain. This other signature
   * may be as simple as a graphical image representing a hand-written signature, or a signature
   * ceremony Different signature approaches have different utilities.
   */
  @Type(() => Signature)
   fixedSignature?: Signature;

  /**
   * Specifies an event that may occur multiple times. Timing schedules are used to record when things
   * are planned, expected or requested to occur. The most common usage is in dosage instructions for
   * medications. They are also used when planning care of various kinds, and may be used for reporting
   * the schedule to which past regular activities were carried out.
   */
  @Type(() => Timing)
   fixedTiming?: Timing;

  /**
   * Specifies contact information for a person or organization.
   */
  @Type(() => ContactDetail)
   fixedContactDetail?: ContactDetail;

  /**
   * A contributor to the content of a knowledge asset, including authors, editors, reviewers, and
   * endorsers.
   */
  @Type(() => Contributor)
   fixedContributor?: Contributor;

  /**
   * Describes a required data item for evaluation in terms of the type of data, and optional code or
   * date-based filters of the data.
   */
  @Type(() => DataRequirement)
   fixedDataRequirement?: DataRequirement;

  /**
   * A expression that is evaluated in a specified context and returns a value. The context of use of
   * the expression must specify the context in which the expression is evaluated, and how the result
   * of the expression is used.
   */
  @Type(() => Expression)
   fixedExpression?: Expression;

  /**
   * The parameters to the module. This collection specifies both the input and output parameters. Input
   * parameters are provided by the caller as part of the $evaluate operation. Output parameters are
   * included in the GuidanceResponse.
   */
  @Type(() => ParameterDefinition)
   fixedParameterDefinition?: ParameterDefinition;

  /**
   * Related artifacts such as additional documentation, justification, or bibliographic references.
   */
  @Type(() => RelatedArtifact)
   fixedRelatedArtifact?: RelatedArtifact;

  /**
   * A description of a triggering event. Triggering events can be named events, data events, or
   * periodic, as determined by the type element.
   */
  @Type(() => TriggerDefinition)
   fixedTriggerDefinition?: TriggerDefinition;

  /**
   * Specifies clinical/business/etc. metadata that can be used to retrieve, index and/or categorize an
   * artifact. This metadata can either be specific to the applicable population (e.g., age category,
   * DRG) or the specific context of care (e.g., venue, care setting, provider of care).
   */
  @Type(() => UsageContext)
   fixedUsageContext?: UsageContext;

  /**
   * Indicates how the medication is/was taken or should be taken by the patient.
   */
  @Type(() => Dosage)
   fixedDosage?: Dosage;

  /**
   * The metadata about a resource. This is content in the resource that is maintained by the
   * infrastructure. Changes to the content might not always be associated with version changes to the
   * resource.
   */
  @Type(() => Meta)
   fixedMeta?: Meta;

  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern
   * must be found in the instance. Other additional values may be found too. This is effectively
   * constraint by example.
   * 
   * When pattern[x] is used to constrain a primitive, it means that the value provided in the
   * pattern[x] must match the instance value exactly.
   * 
   * When pattern[x] is used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the instance array.
   * 
   * When pattern[x] is used to constrain a complex object, it means that each property in the pattern
   * must be present in the complex object, and its value must recursively match -- i.e.,
   * 
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   * Field access restricted because there are specific valid values.
   */
  protected patternBase64Binary?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _patternBase64Binary?: Element;

  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern
   * must be found in the instance. Other additional values may be found too. This is effectively
   * constraint by example.
   * 
   * When pattern[x] is used to constrain a primitive, it means that the value provided in the
   * pattern[x] must match the instance value exactly.
   * 
   * When pattern[x] is used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the instance array.
   * 
   * When pattern[x] is used to constrain a complex object, it means that each property in the pattern
   * must be present in the complex object, and its value must recursively match -- i.e.,
   * 
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
   patternBoolean?: boolean;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _patternBoolean?: Element;

  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern
   * must be found in the instance. Other additional values may be found too. This is effectively
   * constraint by example.
   * 
   * When pattern[x] is used to constrain a primitive, it means that the value provided in the
   * pattern[x] must match the instance value exactly.
   * 
   * When pattern[x] is used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the instance array.
   * 
   * When pattern[x] is used to constrain a complex object, it means that each property in the pattern
   * must be present in the complex object, and its value must recursively match -- i.e.,
   * 
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   * Field access restricted because there are specific valid values.
   */
  protected patternCanonical?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _patternCanonical?: Element;

  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern
   * must be found in the instance. Other additional values may be found too. This is effectively
   * constraint by example.
   * 
   * When pattern[x] is used to constrain a primitive, it means that the value provided in the
   * pattern[x] must match the instance value exactly.
   * 
   * When pattern[x] is used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the instance array.
   * 
   * When pattern[x] is used to constrain a complex object, it means that each property in the pattern
   * must be present in the complex object, and its value must recursively match -- i.e.,
   * 
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   * Field access restricted because there are specific valid values.
   */
  protected patternCode?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _patternCode?: Element;

  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern
   * must be found in the instance. Other additional values may be found too. This is effectively
   * constraint by example.
   * 
   * When pattern[x] is used to constrain a primitive, it means that the value provided in the
   * pattern[x] must match the instance value exactly.
   * 
   * When pattern[x] is used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the instance array.
   * 
   * When pattern[x] is used to constrain a complex object, it means that each property in the pattern
   * must be present in the complex object, and its value must recursively match -- i.e.,
   * 
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   * Field access restricted because there are specific valid values.
   */
  protected patternDate?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _patternDate?: Element;

  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern
   * must be found in the instance. Other additional values may be found too. This is effectively
   * constraint by example.
   * 
   * When pattern[x] is used to constrain a primitive, it means that the value provided in the
   * pattern[x] must match the instance value exactly.
   * 
   * When pattern[x] is used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the instance array.
   * 
   * When pattern[x] is used to constrain a complex object, it means that each property in the pattern
   * must be present in the complex object, and its value must recursively match -- i.e.,
   * 
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   * Field access restricted because there are specific valid values.
   */
  protected patternDateTime?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _patternDateTime?: Element;

  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern
   * must be found in the instance. Other additional values may be found too. This is effectively
   * constraint by example.
   * 
   * When pattern[x] is used to constrain a primitive, it means that the value provided in the
   * pattern[x] must match the instance value exactly.
   * 
   * When pattern[x] is used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the instance array.
   * 
   * When pattern[x] is used to constrain a complex object, it means that each property in the pattern
   * must be present in the complex object, and its value must recursively match -- i.e.,
   * 
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
   patternDecimal?: number;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _patternDecimal?: Element;

  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern
   * must be found in the instance. Other additional values may be found too. This is effectively
   * constraint by example.
   * 
   * When pattern[x] is used to constrain a primitive, it means that the value provided in the
   * pattern[x] must match the instance value exactly.
   * 
   * When pattern[x] is used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the instance array.
   * 
   * When pattern[x] is used to constrain a complex object, it means that each property in the pattern
   * must be present in the complex object, and its value must recursively match -- i.e.,
   * 
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   * Field access restricted because there are specific valid values.
   */
  protected patternId?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _patternId?: Element;

  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern
   * must be found in the instance. Other additional values may be found too. This is effectively
   * constraint by example.
   * 
   * When pattern[x] is used to constrain a primitive, it means that the value provided in the
   * pattern[x] must match the instance value exactly.
   * 
   * When pattern[x] is used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the instance array.
   * 
   * When pattern[x] is used to constrain a complex object, it means that each property in the pattern
   * must be present in the complex object, and its value must recursively match -- i.e.,
   * 
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   * Field access restricted because there are specific valid values.
   */
  protected patternInstant?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _patternInstant?: Element;

  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern
   * must be found in the instance. Other additional values may be found too. This is effectively
   * constraint by example.
   * 
   * When pattern[x] is used to constrain a primitive, it means that the value provided in the
   * pattern[x] must match the instance value exactly.
   * 
   * When pattern[x] is used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the instance array.
   * 
   * When pattern[x] is used to constrain a complex object, it means that each property in the pattern
   * must be present in the complex object, and its value must recursively match -- i.e.,
   * 
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
   patternInteger?: number;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _patternInteger?: Element;

  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern
   * must be found in the instance. Other additional values may be found too. This is effectively
   * constraint by example.
   * 
   * When pattern[x] is used to constrain a primitive, it means that the value provided in the
   * pattern[x] must match the instance value exactly.
   * 
   * When pattern[x] is used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the instance array.
   * 
   * When pattern[x] is used to constrain a complex object, it means that each property in the pattern
   * must be present in the complex object, and its value must recursively match -- i.e.,
   * 
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   * Field access restricted because there are specific valid values.
   */
  protected patternMarkdown?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _patternMarkdown?: Element;

  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern
   * must be found in the instance. Other additional values may be found too. This is effectively
   * constraint by example.
   * 
   * When pattern[x] is used to constrain a primitive, it means that the value provided in the
   * pattern[x] must match the instance value exactly.
   * 
   * When pattern[x] is used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the instance array.
   * 
   * When pattern[x] is used to constrain a complex object, it means that each property in the pattern
   * must be present in the complex object, and its value must recursively match -- i.e.,
   * 
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   * Field access restricted because there are specific valid values.
   */
  protected patternOid?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _patternOid?: Element;

  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern
   * must be found in the instance. Other additional values may be found too. This is effectively
   * constraint by example.
   * 
   * When pattern[x] is used to constrain a primitive, it means that the value provided in the
   * pattern[x] must match the instance value exactly.
   * 
   * When pattern[x] is used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the instance array.
   * 
   * When pattern[x] is used to constrain a complex object, it means that each property in the pattern
   * must be present in the complex object, and its value must recursively match -- i.e.,
   * 
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
   patternPositiveInt?: number;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _patternPositiveInt?: Element;

  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern
   * must be found in the instance. Other additional values may be found too. This is effectively
   * constraint by example.
   * 
   * When pattern[x] is used to constrain a primitive, it means that the value provided in the
   * pattern[x] must match the instance value exactly.
   * 
   * When pattern[x] is used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the instance array.
   * 
   * When pattern[x] is used to constrain a complex object, it means that each property in the pattern
   * must be present in the complex object, and its value must recursively match -- i.e.,
   * 
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   * Field access restricted because there are specific valid values.
   */
  protected patternString?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _patternString?: Element;

  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern
   * must be found in the instance. Other additional values may be found too. This is effectively
   * constraint by example.
   * 
   * When pattern[x] is used to constrain a primitive, it means that the value provided in the
   * pattern[x] must match the instance value exactly.
   * 
   * When pattern[x] is used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the instance array.
   * 
   * When pattern[x] is used to constrain a complex object, it means that each property in the pattern
   * must be present in the complex object, and its value must recursively match -- i.e.,
   * 
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   * Field access restricted because there are specific valid values.
   */
  protected patternTime?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _patternTime?: Element;

  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern
   * must be found in the instance. Other additional values may be found too. This is effectively
   * constraint by example.
   * 
   * When pattern[x] is used to constrain a primitive, it means that the value provided in the
   * pattern[x] must match the instance value exactly.
   * 
   * When pattern[x] is used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the instance array.
   * 
   * When pattern[x] is used to constrain a complex object, it means that each property in the pattern
   * must be present in the complex object, and its value must recursively match -- i.e.,
   * 
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   */
   patternUnsignedInt?: number;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _patternUnsignedInt?: Element;

  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern
   * must be found in the instance. Other additional values may be found too. This is effectively
   * constraint by example.
   * 
   * When pattern[x] is used to constrain a primitive, it means that the value provided in the
   * pattern[x] must match the instance value exactly.
   * 
   * When pattern[x] is used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the instance array.
   * 
   * When pattern[x] is used to constrain a complex object, it means that each property in the pattern
   * must be present in the complex object, and its value must recursively match -- i.e.,
   * 
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   * Field access restricted because there are specific valid values.
   */
  protected patternUri?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _patternUri?: Element;

  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern
   * must be found in the instance. Other additional values may be found too. This is effectively
   * constraint by example.
   * 
   * When pattern[x] is used to constrain a primitive, it means that the value provided in the
   * pattern[x] must match the instance value exactly.
   * 
   * When pattern[x] is used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the instance array.
   * 
   * When pattern[x] is used to constrain a complex object, it means that each property in the pattern
   * must be present in the complex object, and its value must recursively match -- i.e.,
   * 
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   * Field access restricted because there are specific valid values.
   */
  protected patternUrl?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _patternUrl?: Element;

  /**
   * Specifies a value that the value in the instance SHALL follow - that is, any value in the pattern
   * must be found in the instance. Other additional values may be found too. This is effectively
   * constraint by example.
   * 
   * When pattern[x] is used to constrain a primitive, it means that the value provided in the
   * pattern[x] must match the instance value exactly.
   * 
   * When pattern[x] is used to constrain an array, it means that each element provided in the
   * pattern[x] array must (recursively) match at least one element from the instance array.
   * 
   * When pattern[x] is used to constrain a complex object, it means that each property in the pattern
   * must be present in the complex object, and its value must recursively match -- i.e.,
   * 
   * 1. If primitive: it must match exactly the pattern value
   * 2. If a complex object: it must match (recursively) the pattern value
   * 3. If an array: it must match (recursively) the pattern value.
   * Field access restricted because there are specific valid values.
   */
  protected patternUuid?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _patternUuid?: Element;

  /**
   * An address expressed using postal conventions (as opposed to GPS or other location definition
   * formats).  This data type may be used to convey addresses for use in delivering mail as well as
   * for visiting locations which might not be valid for mail delivery.  There are a variety of postal
   * address formats defined around the world.
   */
  @Type(() => Address)
   patternAddress?: Address;

  /**
   * A duration of time during which an organism (or a process) has existed.
   */
  @Type(() => Age)
   patternAge?: Age;

  /**
   * A  text note which also  contains information about who made the statement and when.
   */
  @Type(() => Annotation)
   patternAnnotation?: Annotation;

  /**
   * For referring to data content defined in other formats.
   */
  @Type(() => Attachment)
   patternAttachment?: Attachment;

  /**
   * A concept that may be defined by a formal reference to a terminology or ontology or may be provided
   * by text.
   */
  @Type(() => CodeableConcept)
   patternCodeableConcept?: CodeableConcept;

  /**
   * A reference to a code defined by a terminology system.
   */
  @Type(() => Coding)
   patternCoding?: Coding;

  /**
   * Details for all kinds of technology mediated contact points for a person or organization, including
   * telephone, email, etc.
   */
  @Type(() => ContactPoint)
   patternContactPoint?: ContactPoint;

  /**
   * A measured amount (or an amount that can potentially be measured). Note that measured amounts
   * include amounts that are not precisely quantified, including amounts involving arbitrary units and
   * floating currencies.
   */
  @Type(() => Count)
   patternCount?: Count;

  /**
   * A length - a value with a unit that is a physical distance.
   */
  @Type(() => Distance)
   patternDistance?: Distance;

  /**
   * A length of time.
   */
  @Type(() => Duration)
   patternDuration?: Duration;

  /**
   * A human's name with the ability to identify parts and usage.
   */
  @Type(() => HumanName)
   patternHumanName?: HumanName;

  /**
   * An identifier - identifies some entity uniquely and unambiguously. Typically this is used for
   * business identifiers.
   */
  @Type(() => Identifier)
   patternIdentifier?: Identifier;

  /**
   * An amount of economic utility in some recognized currency.
   */
  @Type(() => Money)
   patternMoney?: Money;

  /**
   * A time period defined by a start and end date and optionally time.
   */
  @Type(() => Period)
   patternPeriod?: Period;

  /**
   * A measured amount (or an amount that can potentially be measured). Note that measured amounts
   * include amounts that are not precisely quantified, including amounts involving arbitrary units and
   * floating currencies.
   */
  @Type(() => Quantity)
   patternQuantity?: Quantity;

  /**
   * A set of ordered Quantities defined by a low and high limit.
   */
  @Type(() => Range)
   patternRange?: Range;

  /**
   * A relationship of two Quantity values - expressed as a numerator and a denominator.
   */
  @Type(() => Ratio)
   patternRatio?: Ratio;

  /**
   * A reference from one resource to another.
   */
  @Type(() => Reference)
   patternReference?: Reference;

  /**
   * A series of measurements taken by a device, with upper and lower limits. There may be more than one
   * dimension in the data.
   */
  @Type(() => SampledData)
   patternSampledData?: SampledData;

  /**
   * A signature along with supporting context. The signature may be a digital signature that is
   * cryptographic in nature, or some other signature acceptable to the domain. This other signature
   * may be as simple as a graphical image representing a hand-written signature, or a signature
   * ceremony Different signature approaches have different utilities.
   */
  @Type(() => Signature)
   patternSignature?: Signature;

  /**
   * Specifies an event that may occur multiple times. Timing schedules are used to record when things
   * are planned, expected or requested to occur. The most common usage is in dosage instructions for
   * medications. They are also used when planning care of various kinds, and may be used for reporting
   * the schedule to which past regular activities were carried out.
   */
  @Type(() => Timing)
   patternTiming?: Timing;

  /**
   * Specifies contact information for a person or organization.
   */
  @Type(() => ContactDetail)
   patternContactDetail?: ContactDetail;

  /**
   * A contributor to the content of a knowledge asset, including authors, editors, reviewers, and
   * endorsers.
   */
  @Type(() => Contributor)
   patternContributor?: Contributor;

  /**
   * Describes a required data item for evaluation in terms of the type of data, and optional code or
   * date-based filters of the data.
   */
  @Type(() => DataRequirement)
   patternDataRequirement?: DataRequirement;

  /**
   * A expression that is evaluated in a specified context and returns a value. The context of use of
   * the expression must specify the context in which the expression is evaluated, and how the result
   * of the expression is used.
   */
  @Type(() => Expression)
   patternExpression?: Expression;

  /**
   * The parameters to the module. This collection specifies both the input and output parameters. Input
   * parameters are provided by the caller as part of the $evaluate operation. Output parameters are
   * included in the GuidanceResponse.
   */
  @Type(() => ParameterDefinition)
   patternParameterDefinition?: ParameterDefinition;

  /**
   * Related artifacts such as additional documentation, justification, or bibliographic references.
   */
  @Type(() => RelatedArtifact)
   patternRelatedArtifact?: RelatedArtifact;

  /**
   * A description of a triggering event. Triggering events can be named events, data events, or
   * periodic, as determined by the type element.
   */
  @Type(() => TriggerDefinition)
   patternTriggerDefinition?: TriggerDefinition;

  /**
   * Specifies clinical/business/etc. metadata that can be used to retrieve, index and/or categorize an
   * artifact. This metadata can either be specific to the applicable population (e.g., age category,
   * DRG) or the specific context of care (e.g., venue, care setting, provider of care).
   */
  @Type(() => UsageContext)
   patternUsageContext?: UsageContext;

  /**
   * Indicates how the medication is/was taken or should be taken by the patient.
   */
  @Type(() => Dosage)
   patternDosage?: Dosage;

  /**
   * The metadata about a resource. This is content in the resource that is maintained by the
   * infrastructure. Changes to the content might not always be associated with version changes to the
   * resource.
   */
  @Type(() => Meta)
   patternMeta?: Meta;

  /**
   * A sample value for this element demonstrating the type of information that would typically be found
   * in the element.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => ElementDefinitionExample)
  protected example?: ElementDefinitionExample[];

  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types
   * date, dateTime, instant, time, decimal, integer, and Quantity.
   * Field access restricted because there are specific valid values.
   */
  protected minValueDate?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _minValueDate?: Element;

  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types
   * date, dateTime, instant, time, decimal, integer, and Quantity.
   * Field access restricted because there are specific valid values.
   */
  protected minValueDateTime?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _minValueDateTime?: Element;

  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types
   * date, dateTime, instant, time, decimal, integer, and Quantity.
   * Field access restricted because there are specific valid values.
   */
  protected minValueInstant?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _minValueInstant?: Element;

  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types
   * date, dateTime, instant, time, decimal, integer, and Quantity.
   * Field access restricted because there are specific valid values.
   */
  protected minValueTime?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _minValueTime?: Element;

  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types
   * date, dateTime, instant, time, decimal, integer, and Quantity.
   */
   minValueDecimal?: number;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _minValueDecimal?: Element;

  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types
   * date, dateTime, instant, time, decimal, integer, and Quantity.
   */
   minValueInteger?: number;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _minValueInteger?: Element;

  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types
   * date, dateTime, instant, time, decimal, integer, and Quantity.
   */
   minValuePositiveInt?: number;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _minValuePositiveInt?: Element;

  /**
   * The minimum allowed value for the element. The value is inclusive. This is allowed for the types
   * date, dateTime, instant, time, decimal, integer, and Quantity.
   */
   minValueUnsignedInt?: number;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _minValueUnsignedInt?: Element;

  /**
   * A measured amount (or an amount that can potentially be measured). Note that measured amounts
   * include amounts that are not precisely quantified, including amounts involving arbitrary units and
   * floating currencies.
   */
  @Type(() => Quantity)
   minValueQuantity?: Quantity;

  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types
   * date, dateTime, instant, time, decimal, integer, and Quantity.
   * Field access restricted because there are specific valid values.
   */
  protected maxValueDate?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _maxValueDate?: Element;

  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types
   * date, dateTime, instant, time, decimal, integer, and Quantity.
   * Field access restricted because there are specific valid values.
   */
  protected maxValueDateTime?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _maxValueDateTime?: Element;

  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types
   * date, dateTime, instant, time, decimal, integer, and Quantity.
   * Field access restricted because there are specific valid values.
   */
  protected maxValueInstant?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _maxValueInstant?: Element;

  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types
   * date, dateTime, instant, time, decimal, integer, and Quantity.
   * Field access restricted because there are specific valid values.
   */
  protected maxValueTime?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _maxValueTime?: Element;

  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types
   * date, dateTime, instant, time, decimal, integer, and Quantity.
   */
   maxValueDecimal?: number;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _maxValueDecimal?: Element;

  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types
   * date, dateTime, instant, time, decimal, integer, and Quantity.
   */
   maxValueInteger?: number;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _maxValueInteger?: Element;

  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types
   * date, dateTime, instant, time, decimal, integer, and Quantity.
   */
   maxValuePositiveInt?: number;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _maxValuePositiveInt?: Element;

  /**
   * The maximum allowed value for the element. The value is inclusive. This is allowed for the types
   * date, dateTime, instant, time, decimal, integer, and Quantity.
   */
   maxValueUnsignedInt?: number;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _maxValueUnsignedInt?: Element;

  /**
   * A measured amount (or an amount that can potentially be measured). Note that measured amounts
   * include amounts that are not precisely quantified, including amounts involving arbitrary units and
   * floating currencies.
   */
  @Type(() => Quantity)
   maxValueQuantity?: Quantity;

  /**
   * A whole number
   */
   maxLength?: number;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _maxLength?: Element;

  /**
   * A reference to an invariant that may make additional statements about the cardinality or value in
   * the instance.
   * Field access restricted because there are specific valid values.
   */
  protected condition?: string[];

  /**
   * Extensions for condition
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Element)
  protected _condition?: Element[];

  /**
   * Formal constraints such as co-occurrence and other constraints that can be computationally
   * evaluated within the context of the instance.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => ElementDefinitionConstraint)
  protected constraint?: ElementDefinitionConstraint[];

  /**
   * Value of "true" or "false"
   */
   mustSupport?: boolean;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _mustSupport?: Element;

  /**
   * Value of "true" or "false"
   */
   isModifier?: boolean;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _isModifier?: Element;

  /**
   * A sequence of Unicode characters
   * Field access restricted because there are specific valid values.
   */
  protected isModifierReason?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _isModifierReason?: Element;

  /**
   * Value of "true" or "false"
   */
   isSummary?: boolean;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _isSummary?: Element;

  /**
   * Captures constraints on each element within the resource, profile, or extension.
   */
  @Type(() => ElementDefinitionBinding)
   binding?: ElementDefinitionBinding;

  /**
   * Identifies a concept from an external specification that roughly corresponds to this element.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => ElementDefinitionMapping)
  protected mapping?: ElementDefinitionMapping[];


  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setId(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.id) !== 'undefined') {
         delete this.id;
      }
      return;
    }
    
    if (REGEX_ID.test(newValue)) {
      this.id = newValue
    } else {
      throw new Error("Invalid value pattern for id of " + newValue);
    }
  }
  
  public getIdPattern(): string {
    return REGEX_ID.source;
  }
  

  public getId(): string | undefined {
      return this.id;
  }

  public addExtension(newValue: Extension) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.extension) !== 'undefined') {
         delete this.extension;
      }
      return;
    }
    
    if (typeof(this.extension) === 'undefined') {
      this.extension =  [];
    }
    this.extension.push(newValue);
  }

  public getExtension(): Extension[] | undefined {
      return this.extension;
  }

  public addModifierExtension(newValue: Extension) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.modifierExtension) !== 'undefined') {
         delete this.modifierExtension;
      }
      return;
    }
    
    if (typeof(this.modifierExtension) === 'undefined') {
      this.modifierExtension =  [];
    }
    this.modifierExtension.push(newValue);
  }

  public getModifierExtension(): Extension[] | undefined {
      return this.modifierExtension;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setPath(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.path) !== 'undefined') {
         delete this.path;
      }
      return;
    }
    
    if (REGEX_PATH.test(newValue)) {
      this.path = newValue
    } else {
      throw new Error("Invalid value pattern for path of " + newValue);
    }
  }
  
  public getPathPattern(): string {
    return REGEX_PATH.source;
  }
  

  public getPath(): string | undefined {
      return this.path;
  }

  public addRepresentation(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.representation) !== 'undefined') {
         delete this.representation;
      }
      return;
    }
    
    if (typeof(this.representation) === 'undefined') {
      this.representation =  [];
    }
    this.representation.push(newValue);
  }

  public getRepresentation(): string[] | undefined {
      return this.representation;
  }

  public add_representation(newValue: Element) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this._representation) !== 'undefined') {
         delete this._representation;
      }
      return;
    }
    
    if (typeof(this._representation) === 'undefined') {
      this._representation =  [];
    }
    this._representation.push(newValue);
  }

  public get_representation(): Element[] | undefined {
      return this._representation;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setSliceName(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.sliceName) !== 'undefined') {
         delete this.sliceName;
      }
      return;
    }
    
    if (REGEX_SLICENAME.test(newValue)) {
      this.sliceName = newValue
    } else {
      throw new Error("Invalid value pattern for sliceName of " + newValue);
    }
  }
  
  public getSliceNamePattern(): string {
    return REGEX_SLICENAME.source;
  }
  

  public getSliceName(): string | undefined {
      return this.sliceName;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setLabel(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.label) !== 'undefined') {
         delete this.label;
      }
      return;
    }
    
    if (REGEX_LABEL.test(newValue)) {
      this.label = newValue
    } else {
      throw new Error("Invalid value pattern for label of " + newValue);
    }
  }
  
  public getLabelPattern(): string {
    return REGEX_LABEL.source;
  }
  

  public getLabel(): string | undefined {
      return this.label;
  }

  public addCode(newValue: Coding) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.code) !== 'undefined') {
         delete this.code;
      }
      return;
    }
    
    if (typeof(this.code) === 'undefined') {
      this.code =  [];
    }
    this.code.push(newValue);
  }

  public getCode(): Coding[] | undefined {
      return this.code;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setShort(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.short) !== 'undefined') {
         delete this.short;
      }
      return;
    }
    
    if (REGEX_SHORT.test(newValue)) {
      this.short = newValue
    } else {
      throw new Error("Invalid value pattern for short of " + newValue);
    }
  }
  
  public getShortPattern(): string {
    return REGEX_SHORT.source;
  }
  

  public getShort(): string | undefined {
      return this.short;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setDefinition(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.definition) !== 'undefined') {
         delete this.definition;
      }
      return;
    }
    
    if (REGEX_DEFINITION.test(newValue)) {
      this.definition = newValue
    } else {
      throw new Error("Invalid value pattern for definition of " + newValue);
    }
  }
  
  public getDefinitionPattern(): string {
    return REGEX_DEFINITION.source;
  }
  

  public getDefinition(): string | undefined {
      return this.definition;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setComment(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.comment) !== 'undefined') {
         delete this.comment;
      }
      return;
    }
    
    if (REGEX_COMMENT.test(newValue)) {
      this.comment = newValue
    } else {
      throw new Error("Invalid value pattern for comment of " + newValue);
    }
  }
  
  public getCommentPattern(): string {
    return REGEX_COMMENT.source;
  }
  

  public getComment(): string | undefined {
      return this.comment;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setRequirements(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.requirements) !== 'undefined') {
         delete this.requirements;
      }
      return;
    }
    
    if (REGEX_REQUIREMENTS.test(newValue)) {
      this.requirements = newValue
    } else {
      throw new Error("Invalid value pattern for requirements of " + newValue);
    }
  }
  
  public getRequirementsPattern(): string {
    return REGEX_REQUIREMENTS.source;
  }
  

  public getRequirements(): string | undefined {
      return this.requirements;
  }

  public addAlias(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.alias) !== 'undefined') {
         delete this.alias;
      }
      return;
    }
    
    if (typeof(this.alias) === 'undefined') {
      this.alias =  [];
    }
    this.alias.push(newValue);
  }

  public getAlias(): string[] | undefined {
      return this.alias;
  }

  public add_alias(newValue: Element) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this._alias) !== 'undefined') {
         delete this._alias;
      }
      return;
    }
    
    if (typeof(this._alias) === 'undefined') {
      this._alias =  [];
    }
    this._alias.push(newValue);
  }

  public get_alias(): Element[] | undefined {
      return this._alias;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setMax(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.max) !== 'undefined') {
         delete this.max;
      }
      return;
    }
    
    if (REGEX_MAX.test(newValue)) {
      this.max = newValue
    } else {
      throw new Error("Invalid value pattern for max of " + newValue);
    }
  }
  
  public getMaxPattern(): string {
    return REGEX_MAX.source;
  }
  

  public getMax(): string | undefined {
      return this.max;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setContentReference(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.contentReference) !== 'undefined') {
         delete this.contentReference;
      }
      return;
    }
    
    if (REGEX_CONTENTREFERENCE.test(newValue)) {
      this.contentReference = newValue
    } else {
      throw new Error("Invalid value pattern for contentReference of " + newValue);
    }
  }
  
  public getContentReferencePattern(): string {
    return REGEX_CONTENTREFERENCE.source;
  }
  

  public getContentReference(): string | undefined {
      return this.contentReference;
  }

  public addType(newValue: ElementDefinitionType) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.type) !== 'undefined') {
         delete this.type;
      }
      return;
    }
    
    if (typeof(this.type) === 'undefined') {
      this.type =  [];
    }
    this.type.push(newValue);
  }

  public getType(): ElementDefinitionType[] | undefined {
      return this.type;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setDefaultValueBase64Binary(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.defaultValueBase64Binary) !== 'undefined') {
         delete this.defaultValueBase64Binary;
      }
      return;
    }
    
    if (REGEX_DEFAULTVALUEBASE64BINARY.test(newValue)) {
      this.defaultValueBase64Binary = newValue
    } else {
      throw new Error("Invalid value pattern for defaultValueBase64Binary of " + newValue);
    }
  }
  
  public getDefaultValueBase64BinaryPattern(): string {
    return REGEX_DEFAULTVALUEBASE64BINARY.source;
  }
  

  public getDefaultValueBase64Binary(): string | undefined {
      return this.defaultValueBase64Binary;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setDefaultValueCanonical(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.defaultValueCanonical) !== 'undefined') {
         delete this.defaultValueCanonical;
      }
      return;
    }
    
    if (REGEX_DEFAULTVALUECANONICAL.test(newValue)) {
      this.defaultValueCanonical = newValue
    } else {
      throw new Error("Invalid value pattern for defaultValueCanonical of " + newValue);
    }
  }
  
  public getDefaultValueCanonicalPattern(): string {
    return REGEX_DEFAULTVALUECANONICAL.source;
  }
  

  public getDefaultValueCanonical(): string | undefined {
      return this.defaultValueCanonical;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setDefaultValueCode(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.defaultValueCode) !== 'undefined') {
         delete this.defaultValueCode;
      }
      return;
    }
    
    if (REGEX_DEFAULTVALUECODE.test(newValue)) {
      this.defaultValueCode = newValue
    } else {
      throw new Error("Invalid value pattern for defaultValueCode of " + newValue);
    }
  }
  
  public getDefaultValueCodePattern(): string {
    return REGEX_DEFAULTVALUECODE.source;
  }
  

  public getDefaultValueCode(): string | undefined {
      return this.defaultValueCode;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setDefaultValueDate(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.defaultValueDate) !== 'undefined') {
         delete this.defaultValueDate;
      }
      return;
    }
    
    if (REGEX_DEFAULTVALUEDATE.test(newValue)) {
      this.defaultValueDate = newValue
    } else {
      throw new Error("Invalid value pattern for defaultValueDate of " + newValue);
    }
  }
  
  public getDefaultValueDatePattern(): string {
    return REGEX_DEFAULTVALUEDATE.source;
  }
  

  public getDefaultValueDate(): string | undefined {
      return this.defaultValueDate;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setDefaultValueDateTime(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.defaultValueDateTime) !== 'undefined') {
         delete this.defaultValueDateTime;
      }
      return;
    }
    
    if (REGEX_DEFAULTVALUEDATETIME.test(newValue)) {
      this.defaultValueDateTime = newValue
    } else {
      throw new Error("Invalid value pattern for defaultValueDateTime of " + newValue);
    }
  }
  
  public getDefaultValueDateTimePattern(): string {
    return REGEX_DEFAULTVALUEDATETIME.source;
  }
  

  public getDefaultValueDateTime(): string | undefined {
      return this.defaultValueDateTime;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setDefaultValueId(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.defaultValueId) !== 'undefined') {
         delete this.defaultValueId;
      }
      return;
    }
    
    if (REGEX_DEFAULTVALUEID.test(newValue)) {
      this.defaultValueId = newValue
    } else {
      throw new Error("Invalid value pattern for defaultValueId of " + newValue);
    }
  }
  
  public getDefaultValueIdPattern(): string {
    return REGEX_DEFAULTVALUEID.source;
  }
  

  public getDefaultValueId(): string | undefined {
      return this.defaultValueId;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setDefaultValueInstant(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.defaultValueInstant) !== 'undefined') {
         delete this.defaultValueInstant;
      }
      return;
    }
    
    if (REGEX_DEFAULTVALUEINSTANT.test(newValue)) {
      this.defaultValueInstant = newValue
    } else {
      throw new Error("Invalid value pattern for defaultValueInstant of " + newValue);
    }
  }
  
  public getDefaultValueInstantPattern(): string {
    return REGEX_DEFAULTVALUEINSTANT.source;
  }
  

  public getDefaultValueInstant(): string | undefined {
      return this.defaultValueInstant;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setDefaultValueMarkdown(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.defaultValueMarkdown) !== 'undefined') {
         delete this.defaultValueMarkdown;
      }
      return;
    }
    
    if (REGEX_DEFAULTVALUEMARKDOWN.test(newValue)) {
      this.defaultValueMarkdown = newValue
    } else {
      throw new Error("Invalid value pattern for defaultValueMarkdown of " + newValue);
    }
  }
  
  public getDefaultValueMarkdownPattern(): string {
    return REGEX_DEFAULTVALUEMARKDOWN.source;
  }
  

  public getDefaultValueMarkdown(): string | undefined {
      return this.defaultValueMarkdown;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setDefaultValueOid(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.defaultValueOid) !== 'undefined') {
         delete this.defaultValueOid;
      }
      return;
    }
    
    if (REGEX_DEFAULTVALUEOID.test(newValue)) {
      this.defaultValueOid = newValue
    } else {
      throw new Error("Invalid value pattern for defaultValueOid of " + newValue);
    }
  }
  
  public getDefaultValueOidPattern(): string {
    return REGEX_DEFAULTVALUEOID.source;
  }
  

  public getDefaultValueOid(): string | undefined {
      return this.defaultValueOid;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setDefaultValueString(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.defaultValueString) !== 'undefined') {
         delete this.defaultValueString;
      }
      return;
    }
    
    if (REGEX_DEFAULTVALUESTRING.test(newValue)) {
      this.defaultValueString = newValue
    } else {
      throw new Error("Invalid value pattern for defaultValueString of " + newValue);
    }
  }
  
  public getDefaultValueStringPattern(): string {
    return REGEX_DEFAULTVALUESTRING.source;
  }
  

  public getDefaultValueString(): string | undefined {
      return this.defaultValueString;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setDefaultValueTime(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.defaultValueTime) !== 'undefined') {
         delete this.defaultValueTime;
      }
      return;
    }
    
    if (REGEX_DEFAULTVALUETIME.test(newValue)) {
      this.defaultValueTime = newValue
    } else {
      throw new Error("Invalid value pattern for defaultValueTime of " + newValue);
    }
  }
  
  public getDefaultValueTimePattern(): string {
    return REGEX_DEFAULTVALUETIME.source;
  }
  

  public getDefaultValueTime(): string | undefined {
      return this.defaultValueTime;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setDefaultValueUri(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.defaultValueUri) !== 'undefined') {
         delete this.defaultValueUri;
      }
      return;
    }
    
    if (REGEX_DEFAULTVALUEURI.test(newValue)) {
      this.defaultValueUri = newValue
    } else {
      throw new Error("Invalid value pattern for defaultValueUri of " + newValue);
    }
  }
  
  public getDefaultValueUriPattern(): string {
    return REGEX_DEFAULTVALUEURI.source;
  }
  

  public getDefaultValueUri(): string | undefined {
      return this.defaultValueUri;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setDefaultValueUrl(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.defaultValueUrl) !== 'undefined') {
         delete this.defaultValueUrl;
      }
      return;
    }
    
    if (REGEX_DEFAULTVALUEURL.test(newValue)) {
      this.defaultValueUrl = newValue
    } else {
      throw new Error("Invalid value pattern for defaultValueUrl of " + newValue);
    }
  }
  
  public getDefaultValueUrlPattern(): string {
    return REGEX_DEFAULTVALUEURL.source;
  }
  

  public getDefaultValueUrl(): string | undefined {
      return this.defaultValueUrl;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setDefaultValueUuid(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.defaultValueUuid) !== 'undefined') {
         delete this.defaultValueUuid;
      }
      return;
    }
    
    if (REGEX_DEFAULTVALUEUUID.test(newValue)) {
      this.defaultValueUuid = newValue
    } else {
      throw new Error("Invalid value pattern for defaultValueUuid of " + newValue);
    }
  }
  
  public getDefaultValueUuidPattern(): string {
    return REGEX_DEFAULTVALUEUUID.source;
  }
  

  public getDefaultValueUuid(): string | undefined {
      return this.defaultValueUuid;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setMeaningWhenMissing(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.meaningWhenMissing) !== 'undefined') {
         delete this.meaningWhenMissing;
      }
      return;
    }
    
    if (REGEX_MEANINGWHENMISSING.test(newValue)) {
      this.meaningWhenMissing = newValue
    } else {
      throw new Error("Invalid value pattern for meaningWhenMissing of " + newValue);
    }
  }
  
  public getMeaningWhenMissingPattern(): string {
    return REGEX_MEANINGWHENMISSING.source;
  }
  

  public getMeaningWhenMissing(): string | undefined {
      return this.meaningWhenMissing;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setOrderMeaning(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.orderMeaning) !== 'undefined') {
         delete this.orderMeaning;
      }
      return;
    }
    
    if (REGEX_ORDERMEANING.test(newValue)) {
      this.orderMeaning = newValue
    } else {
      throw new Error("Invalid value pattern for orderMeaning of " + newValue);
    }
  }
  
  public getOrderMeaningPattern(): string {
    return REGEX_ORDERMEANING.source;
  }
  

  public getOrderMeaning(): string | undefined {
      return this.orderMeaning;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setFixedBase64Binary(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.fixedBase64Binary) !== 'undefined') {
         delete this.fixedBase64Binary;
      }
      return;
    }
    
    if (REGEX_FIXEDBASE64BINARY.test(newValue)) {
      this.fixedBase64Binary = newValue
    } else {
      throw new Error("Invalid value pattern for fixedBase64Binary of " + newValue);
    }
  }
  
  public getFixedBase64BinaryPattern(): string {
    return REGEX_FIXEDBASE64BINARY.source;
  }
  

  public getFixedBase64Binary(): string | undefined {
      return this.fixedBase64Binary;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setFixedCanonical(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.fixedCanonical) !== 'undefined') {
         delete this.fixedCanonical;
      }
      return;
    }
    
    if (REGEX_FIXEDCANONICAL.test(newValue)) {
      this.fixedCanonical = newValue
    } else {
      throw new Error("Invalid value pattern for fixedCanonical of " + newValue);
    }
  }
  
  public getFixedCanonicalPattern(): string {
    return REGEX_FIXEDCANONICAL.source;
  }
  

  public getFixedCanonical(): string | undefined {
      return this.fixedCanonical;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setFixedCode(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.fixedCode) !== 'undefined') {
         delete this.fixedCode;
      }
      return;
    }
    
    if (REGEX_FIXEDCODE.test(newValue)) {
      this.fixedCode = newValue
    } else {
      throw new Error("Invalid value pattern for fixedCode of " + newValue);
    }
  }
  
  public getFixedCodePattern(): string {
    return REGEX_FIXEDCODE.source;
  }
  

  public getFixedCode(): string | undefined {
      return this.fixedCode;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setFixedDate(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.fixedDate) !== 'undefined') {
         delete this.fixedDate;
      }
      return;
    }
    
    if (REGEX_FIXEDDATE.test(newValue)) {
      this.fixedDate = newValue
    } else {
      throw new Error("Invalid value pattern for fixedDate of " + newValue);
    }
  }
  
  public getFixedDatePattern(): string {
    return REGEX_FIXEDDATE.source;
  }
  

  public getFixedDate(): string | undefined {
      return this.fixedDate;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setFixedDateTime(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.fixedDateTime) !== 'undefined') {
         delete this.fixedDateTime;
      }
      return;
    }
    
    if (REGEX_FIXEDDATETIME.test(newValue)) {
      this.fixedDateTime = newValue
    } else {
      throw new Error("Invalid value pattern for fixedDateTime of " + newValue);
    }
  }
  
  public getFixedDateTimePattern(): string {
    return REGEX_FIXEDDATETIME.source;
  }
  

  public getFixedDateTime(): string | undefined {
      return this.fixedDateTime;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setFixedId(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.fixedId) !== 'undefined') {
         delete this.fixedId;
      }
      return;
    }
    
    if (REGEX_FIXEDID.test(newValue)) {
      this.fixedId = newValue
    } else {
      throw new Error("Invalid value pattern for fixedId of " + newValue);
    }
  }
  
  public getFixedIdPattern(): string {
    return REGEX_FIXEDID.source;
  }
  

  public getFixedId(): string | undefined {
      return this.fixedId;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setFixedInstant(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.fixedInstant) !== 'undefined') {
         delete this.fixedInstant;
      }
      return;
    }
    
    if (REGEX_FIXEDINSTANT.test(newValue)) {
      this.fixedInstant = newValue
    } else {
      throw new Error("Invalid value pattern for fixedInstant of " + newValue);
    }
  }
  
  public getFixedInstantPattern(): string {
    return REGEX_FIXEDINSTANT.source;
  }
  

  public getFixedInstant(): string | undefined {
      return this.fixedInstant;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setFixedMarkdown(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.fixedMarkdown) !== 'undefined') {
         delete this.fixedMarkdown;
      }
      return;
    }
    
    if (REGEX_FIXEDMARKDOWN.test(newValue)) {
      this.fixedMarkdown = newValue
    } else {
      throw new Error("Invalid value pattern for fixedMarkdown of " + newValue);
    }
  }
  
  public getFixedMarkdownPattern(): string {
    return REGEX_FIXEDMARKDOWN.source;
  }
  

  public getFixedMarkdown(): string | undefined {
      return this.fixedMarkdown;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setFixedOid(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.fixedOid) !== 'undefined') {
         delete this.fixedOid;
      }
      return;
    }
    
    if (REGEX_FIXEDOID.test(newValue)) {
      this.fixedOid = newValue
    } else {
      throw new Error("Invalid value pattern for fixedOid of " + newValue);
    }
  }
  
  public getFixedOidPattern(): string {
    return REGEX_FIXEDOID.source;
  }
  

  public getFixedOid(): string | undefined {
      return this.fixedOid;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setFixedString(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.fixedString) !== 'undefined') {
         delete this.fixedString;
      }
      return;
    }
    
    if (REGEX_FIXEDSTRING.test(newValue)) {
      this.fixedString = newValue
    } else {
      throw new Error("Invalid value pattern for fixedString of " + newValue);
    }
  }
  
  public getFixedStringPattern(): string {
    return REGEX_FIXEDSTRING.source;
  }
  

  public getFixedString(): string | undefined {
      return this.fixedString;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setFixedTime(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.fixedTime) !== 'undefined') {
         delete this.fixedTime;
      }
      return;
    }
    
    if (REGEX_FIXEDTIME.test(newValue)) {
      this.fixedTime = newValue
    } else {
      throw new Error("Invalid value pattern for fixedTime of " + newValue);
    }
  }
  
  public getFixedTimePattern(): string {
    return REGEX_FIXEDTIME.source;
  }
  

  public getFixedTime(): string | undefined {
      return this.fixedTime;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setFixedUri(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.fixedUri) !== 'undefined') {
         delete this.fixedUri;
      }
      return;
    }
    
    if (REGEX_FIXEDURI.test(newValue)) {
      this.fixedUri = newValue
    } else {
      throw new Error("Invalid value pattern for fixedUri of " + newValue);
    }
  }
  
  public getFixedUriPattern(): string {
    return REGEX_FIXEDURI.source;
  }
  

  public getFixedUri(): string | undefined {
      return this.fixedUri;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setFixedUrl(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.fixedUrl) !== 'undefined') {
         delete this.fixedUrl;
      }
      return;
    }
    
    if (REGEX_FIXEDURL.test(newValue)) {
      this.fixedUrl = newValue
    } else {
      throw new Error("Invalid value pattern for fixedUrl of " + newValue);
    }
  }
  
  public getFixedUrlPattern(): string {
    return REGEX_FIXEDURL.source;
  }
  

  public getFixedUrl(): string | undefined {
      return this.fixedUrl;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setFixedUuid(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.fixedUuid) !== 'undefined') {
         delete this.fixedUuid;
      }
      return;
    }
    
    if (REGEX_FIXEDUUID.test(newValue)) {
      this.fixedUuid = newValue
    } else {
      throw new Error("Invalid value pattern for fixedUuid of " + newValue);
    }
  }
  
  public getFixedUuidPattern(): string {
    return REGEX_FIXEDUUID.source;
  }
  

  public getFixedUuid(): string | undefined {
      return this.fixedUuid;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setPatternBase64Binary(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.patternBase64Binary) !== 'undefined') {
         delete this.patternBase64Binary;
      }
      return;
    }
    
    if (REGEX_PATTERNBASE64BINARY.test(newValue)) {
      this.patternBase64Binary = newValue
    } else {
      throw new Error("Invalid value pattern for patternBase64Binary of " + newValue);
    }
  }
  
  public getPatternBase64BinaryPattern(): string {
    return REGEX_PATTERNBASE64BINARY.source;
  }
  

  public getPatternBase64Binary(): string | undefined {
      return this.patternBase64Binary;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setPatternCanonical(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.patternCanonical) !== 'undefined') {
         delete this.patternCanonical;
      }
      return;
    }
    
    if (REGEX_PATTERNCANONICAL.test(newValue)) {
      this.patternCanonical = newValue
    } else {
      throw new Error("Invalid value pattern for patternCanonical of " + newValue);
    }
  }
  
  public getPatternCanonicalPattern(): string {
    return REGEX_PATTERNCANONICAL.source;
  }
  

  public getPatternCanonical(): string | undefined {
      return this.patternCanonical;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setPatternCode(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.patternCode) !== 'undefined') {
         delete this.patternCode;
      }
      return;
    }
    
    if (REGEX_PATTERNCODE.test(newValue)) {
      this.patternCode = newValue
    } else {
      throw new Error("Invalid value pattern for patternCode of " + newValue);
    }
  }
  
  public getPatternCodePattern(): string {
    return REGEX_PATTERNCODE.source;
  }
  

  public getPatternCode(): string | undefined {
      return this.patternCode;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setPatternDate(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.patternDate) !== 'undefined') {
         delete this.patternDate;
      }
      return;
    }
    
    if (REGEX_PATTERNDATE.test(newValue)) {
      this.patternDate = newValue
    } else {
      throw new Error("Invalid value pattern for patternDate of " + newValue);
    }
  }
  
  public getPatternDatePattern(): string {
    return REGEX_PATTERNDATE.source;
  }
  

  public getPatternDate(): string | undefined {
      return this.patternDate;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setPatternDateTime(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.patternDateTime) !== 'undefined') {
         delete this.patternDateTime;
      }
      return;
    }
    
    if (REGEX_PATTERNDATETIME.test(newValue)) {
      this.patternDateTime = newValue
    } else {
      throw new Error("Invalid value pattern for patternDateTime of " + newValue);
    }
  }
  
  public getPatternDateTimePattern(): string {
    return REGEX_PATTERNDATETIME.source;
  }
  

  public getPatternDateTime(): string | undefined {
      return this.patternDateTime;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setPatternId(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.patternId) !== 'undefined') {
         delete this.patternId;
      }
      return;
    }
    
    if (REGEX_PATTERNID.test(newValue)) {
      this.patternId = newValue
    } else {
      throw new Error("Invalid value pattern for patternId of " + newValue);
    }
  }
  
  public getPatternIdPattern(): string {
    return REGEX_PATTERNID.source;
  }
  

  public getPatternId(): string | undefined {
      return this.patternId;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setPatternInstant(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.patternInstant) !== 'undefined') {
         delete this.patternInstant;
      }
      return;
    }
    
    if (REGEX_PATTERNINSTANT.test(newValue)) {
      this.patternInstant = newValue
    } else {
      throw new Error("Invalid value pattern for patternInstant of " + newValue);
    }
  }
  
  public getPatternInstantPattern(): string {
    return REGEX_PATTERNINSTANT.source;
  }
  

  public getPatternInstant(): string | undefined {
      return this.patternInstant;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setPatternMarkdown(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.patternMarkdown) !== 'undefined') {
         delete this.patternMarkdown;
      }
      return;
    }
    
    if (REGEX_PATTERNMARKDOWN.test(newValue)) {
      this.patternMarkdown = newValue
    } else {
      throw new Error("Invalid value pattern for patternMarkdown of " + newValue);
    }
  }
  
  public getPatternMarkdownPattern(): string {
    return REGEX_PATTERNMARKDOWN.source;
  }
  

  public getPatternMarkdown(): string | undefined {
      return this.patternMarkdown;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setPatternOid(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.patternOid) !== 'undefined') {
         delete this.patternOid;
      }
      return;
    }
    
    if (REGEX_PATTERNOID.test(newValue)) {
      this.patternOid = newValue
    } else {
      throw new Error("Invalid value pattern for patternOid of " + newValue);
    }
  }
  
  public getPatternOidPattern(): string {
    return REGEX_PATTERNOID.source;
  }
  

  public getPatternOid(): string | undefined {
      return this.patternOid;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setPatternString(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.patternString) !== 'undefined') {
         delete this.patternString;
      }
      return;
    }
    
    if (REGEX_PATTERNSTRING.test(newValue)) {
      this.patternString = newValue
    } else {
      throw new Error("Invalid value pattern for patternString of " + newValue);
    }
  }
  
  public getPatternStringPattern(): string {
    return REGEX_PATTERNSTRING.source;
  }
  

  public getPatternString(): string | undefined {
      return this.patternString;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setPatternTime(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.patternTime) !== 'undefined') {
         delete this.patternTime;
      }
      return;
    }
    
    if (REGEX_PATTERNTIME.test(newValue)) {
      this.patternTime = newValue
    } else {
      throw new Error("Invalid value pattern for patternTime of " + newValue);
    }
  }
  
  public getPatternTimePattern(): string {
    return REGEX_PATTERNTIME.source;
  }
  

  public getPatternTime(): string | undefined {
      return this.patternTime;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setPatternUri(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.patternUri) !== 'undefined') {
         delete this.patternUri;
      }
      return;
    }
    
    if (REGEX_PATTERNURI.test(newValue)) {
      this.patternUri = newValue
    } else {
      throw new Error("Invalid value pattern for patternUri of " + newValue);
    }
  }
  
  public getPatternUriPattern(): string {
    return REGEX_PATTERNURI.source;
  }
  

  public getPatternUri(): string | undefined {
      return this.patternUri;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setPatternUrl(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.patternUrl) !== 'undefined') {
         delete this.patternUrl;
      }
      return;
    }
    
    if (REGEX_PATTERNURL.test(newValue)) {
      this.patternUrl = newValue
    } else {
      throw new Error("Invalid value pattern for patternUrl of " + newValue);
    }
  }
  
  public getPatternUrlPattern(): string {
    return REGEX_PATTERNURL.source;
  }
  

  public getPatternUrl(): string | undefined {
      return this.patternUrl;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setPatternUuid(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.patternUuid) !== 'undefined') {
         delete this.patternUuid;
      }
      return;
    }
    
    if (REGEX_PATTERNUUID.test(newValue)) {
      this.patternUuid = newValue
    } else {
      throw new Error("Invalid value pattern for patternUuid of " + newValue);
    }
  }
  
  public getPatternUuidPattern(): string {
    return REGEX_PATTERNUUID.source;
  }
  

  public getPatternUuid(): string | undefined {
      return this.patternUuid;
  }

  public addExample(newValue: ElementDefinitionExample) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.example) !== 'undefined') {
         delete this.example;
      }
      return;
    }
    
    if (typeof(this.example) === 'undefined') {
      this.example =  [];
    }
    this.example.push(newValue);
  }

  public getExample(): ElementDefinitionExample[] | undefined {
      return this.example;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setMinValueDate(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.minValueDate) !== 'undefined') {
         delete this.minValueDate;
      }
      return;
    }
    
    if (REGEX_MINVALUEDATE.test(newValue)) {
      this.minValueDate = newValue
    } else {
      throw new Error("Invalid value pattern for minValueDate of " + newValue);
    }
  }
  
  public getMinValueDatePattern(): string {
    return REGEX_MINVALUEDATE.source;
  }
  

  public getMinValueDate(): string | undefined {
      return this.minValueDate;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setMinValueDateTime(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.minValueDateTime) !== 'undefined') {
         delete this.minValueDateTime;
      }
      return;
    }
    
    if (REGEX_MINVALUEDATETIME.test(newValue)) {
      this.minValueDateTime = newValue
    } else {
      throw new Error("Invalid value pattern for minValueDateTime of " + newValue);
    }
  }
  
  public getMinValueDateTimePattern(): string {
    return REGEX_MINVALUEDATETIME.source;
  }
  

  public getMinValueDateTime(): string | undefined {
      return this.minValueDateTime;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setMinValueInstant(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.minValueInstant) !== 'undefined') {
         delete this.minValueInstant;
      }
      return;
    }
    
    if (REGEX_MINVALUEINSTANT.test(newValue)) {
      this.minValueInstant = newValue
    } else {
      throw new Error("Invalid value pattern for minValueInstant of " + newValue);
    }
  }
  
  public getMinValueInstantPattern(): string {
    return REGEX_MINVALUEINSTANT.source;
  }
  

  public getMinValueInstant(): string | undefined {
      return this.minValueInstant;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setMinValueTime(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.minValueTime) !== 'undefined') {
         delete this.minValueTime;
      }
      return;
    }
    
    if (REGEX_MINVALUETIME.test(newValue)) {
      this.minValueTime = newValue
    } else {
      throw new Error("Invalid value pattern for minValueTime of " + newValue);
    }
  }
  
  public getMinValueTimePattern(): string {
    return REGEX_MINVALUETIME.source;
  }
  

  public getMinValueTime(): string | undefined {
      return this.minValueTime;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setMaxValueDate(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.maxValueDate) !== 'undefined') {
         delete this.maxValueDate;
      }
      return;
    }
    
    if (REGEX_MAXVALUEDATE.test(newValue)) {
      this.maxValueDate = newValue
    } else {
      throw new Error("Invalid value pattern for maxValueDate of " + newValue);
    }
  }
  
  public getMaxValueDatePattern(): string {
    return REGEX_MAXVALUEDATE.source;
  }
  

  public getMaxValueDate(): string | undefined {
      return this.maxValueDate;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setMaxValueDateTime(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.maxValueDateTime) !== 'undefined') {
         delete this.maxValueDateTime;
      }
      return;
    }
    
    if (REGEX_MAXVALUEDATETIME.test(newValue)) {
      this.maxValueDateTime = newValue
    } else {
      throw new Error("Invalid value pattern for maxValueDateTime of " + newValue);
    }
  }
  
  public getMaxValueDateTimePattern(): string {
    return REGEX_MAXVALUEDATETIME.source;
  }
  

  public getMaxValueDateTime(): string | undefined {
      return this.maxValueDateTime;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setMaxValueInstant(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.maxValueInstant) !== 'undefined') {
         delete this.maxValueInstant;
      }
      return;
    }
    
    if (REGEX_MAXVALUEINSTANT.test(newValue)) {
      this.maxValueInstant = newValue
    } else {
      throw new Error("Invalid value pattern for maxValueInstant of " + newValue);
    }
  }
  
  public getMaxValueInstantPattern(): string {
    return REGEX_MAXVALUEINSTANT.source;
  }
  

  public getMaxValueInstant(): string | undefined {
      return this.maxValueInstant;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setMaxValueTime(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.maxValueTime) !== 'undefined') {
         delete this.maxValueTime;
      }
      return;
    }
    
    if (REGEX_MAXVALUETIME.test(newValue)) {
      this.maxValueTime = newValue
    } else {
      throw new Error("Invalid value pattern for maxValueTime of " + newValue);
    }
  }
  
  public getMaxValueTimePattern(): string {
    return REGEX_MAXVALUETIME.source;
  }
  

  public getMaxValueTime(): string | undefined {
      return this.maxValueTime;
  }

  public addCondition(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.condition) !== 'undefined') {
         delete this.condition;
      }
      return;
    }
    
    if (typeof(this.condition) === 'undefined') {
      this.condition =  [];
    }
    this.condition.push(newValue);
  }

  public getCondition(): string[] | undefined {
      return this.condition;
  }

  public add_condition(newValue: Element) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this._condition) !== 'undefined') {
         delete this._condition;
      }
      return;
    }
    
    if (typeof(this._condition) === 'undefined') {
      this._condition =  [];
    }
    this._condition.push(newValue);
  }

  public get_condition(): Element[] | undefined {
      return this._condition;
  }

  public addConstraint(newValue: ElementDefinitionConstraint) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.constraint) !== 'undefined') {
         delete this.constraint;
      }
      return;
    }
    
    if (typeof(this.constraint) === 'undefined') {
      this.constraint =  [];
    }
    this.constraint.push(newValue);
  }

  public getConstraint(): ElementDefinitionConstraint[] | undefined {
      return this.constraint;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setIsModifierReason(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.isModifierReason) !== 'undefined') {
         delete this.isModifierReason;
      }
      return;
    }
    
    if (REGEX_ISMODIFIERREASON.test(newValue)) {
      this.isModifierReason = newValue
    } else {
      throw new Error("Invalid value pattern for isModifierReason of " + newValue);
    }
  }
  
  public getIsModifierReasonPattern(): string {
    return REGEX_ISMODIFIERREASON.source;
  }
  

  public getIsModifierReason(): string | undefined {
      return this.isModifierReason;
  }

  public addMapping(newValue: ElementDefinitionMapping) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.mapping) !== 'undefined') {
         delete this.mapping;
      }
      return;
    }
    
    if (typeof(this.mapping) === 'undefined') {
      this.mapping =  [];
    }
    this.mapping.push(newValue);
  }

  public getMapping(): ElementDefinitionMapping[] | undefined {
      return this.mapping;
  }


}


