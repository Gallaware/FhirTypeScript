import { getValidValueIdx } from '../FhirTsLibValidation/FhirUtils';
import { Type } from 'class-transformer';
import { REGEX_ID, REGEX_CONTEXT, REGEX_ELEMENT, REGEX_VARIABLE, REGEX_LISTRULEID } from '../FhirTsLibValidation/FhirRegex';
import { Element, Extension, StructureMapParameter } from './index';
import { StructureMapTargetContextType_list_ValidValues, StructureMapTargetTransform_list_ValidValues } from '../FhirTsLibValidation/Fhir_ValidValues';



/**
 * A Map of relationships between 2 structures that can be used to transform data.
 *
 * Generated by Gallaware, Inc. from:
 *    file:/Users/admin/Documents/DevNetbeans/jsonSchemaToJava/target/classes/schema/fhir.schema.json#/definitions/StructureMap_Target
 */
export class StructureMapTarget {
  /**
   * A sequence of Unicode characters
   * Field access restricted because there are specific valid values.
   */
  protected id?: string;

  /**
   * May be used to represent additional information that is not part of the basic definition of the
   * element. To make the use of extensions safe and manageable, there is a strict set of governance
   * applied to the definition and use of extensions. Though any implementer can define an extension,
   * there is a set of requirements that SHALL be met as part of the definition of the extension.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Extension)
  protected extension?: Extension[];

  /**
   * May be used to represent additional information that is not part of the basic definition of the
   * element and that modifies the understanding of the element in which it is contained and/or the
   * understanding of the containing element's descendants. Usually modifier elements provide negation
   * or qualification. To make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any implementer can define an
   * extension, there is a set of requirements that SHALL be met as part of the definition of the
   * extension. Applications processing a resource are required to check for modifier extensions.
   * 
   * Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Extension)
  protected modifierExtension?: Extension[];

  /**
   * Any combination of letters, numerals, "-" and ".", with a length limit of 64 characters.  (This
   * might be an integer, an unprefixed OID, UUID or any other identifier pattern that meets these
   * constraints.)  Ids are case-insensitive.
   * Field access restricted because there are specific valid values.
   */
  protected context?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _context?: Element;

  /**
   * How to interpret the context.
   * Field access restricted because there are specific valid values.
   */
  protected contextType?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _contextType?: Element;

  /**
   * A sequence of Unicode characters
   * Field access restricted because there are specific valid values.
   */
  protected element?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _element?: Element;

  /**
   * Any combination of letters, numerals, "-" and ".", with a length limit of 64 characters.  (This
   * might be an integer, an unprefixed OID, UUID or any other identifier pattern that meets these
   * constraints.)  Ids are case-insensitive.
   * Field access restricted because there are specific valid values.
   */
  protected variable?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _variable?: Element;

  /**
   * If field is a list, how to manage the list.
   * Field access restricted because there are specific valid values.
   */
  protected listMode?: string[];

  /**
   * Extensions for listMode
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Element)
  protected _listMode?: Element[];

  /**
   * Any combination of letters, numerals, "-" and ".", with a length limit of 64 characters.  (This
   * might be an integer, an unprefixed OID, UUID or any other identifier pattern that meets these
   * constraints.)  Ids are case-insensitive.
   * Field access restricted because there are specific valid values.
   */
  protected listRuleId?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _listRuleId?: Element;

  /**
   * How the data is copied / created.
   * Field access restricted because there are specific valid values.
   */
  protected transform?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _transform?: Element;

  /**
   * Parameters to the transform.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => StructureMapParameter)
  protected parameter?: StructureMapParameter[];


  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setId(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.id) !== 'undefined') {
         delete this.id;
      }
      return;
    }
    
    if (REGEX_ID.test(newValue)) {
      this.id = newValue
    } else {
      throw new Error("Invalid value pattern for id of " + newValue);
    }
  }
  
  public getIdPattern(): string {
    return REGEX_ID.source;
  }
  
  /**
  * Gets the current value of field id.
  * @returns the value  or undefined
  */
  public getId(): string | undefined {
      return this.id;
  }

  public addExtension(newValue: Extension) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.extension) !== 'undefined') {
         delete this.extension;
      }
      return;
    }
    
    if (typeof(this.extension) === 'undefined') {
      this.extension =  [];
    }
    this.extension.push(newValue);
  }
  /**
  * Removes all elements from the array extension, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteExtensionAll(): Extension[] {
    if (typeof(this.extension) !== 'undefined') {
       const oldArray = this.extension;
       delete this.extension;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array extension, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteExtensionBySplice(start: number, deleteCount?: number): Extension[] {
    if (typeof(this.extension) !== 'undefined') {
       return this.extension.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field extension.
  * @returns the value  or undefined
  */
  public getExtension(): Extension[] | undefined {
      return this.extension;
  }

  public addModifierExtension(newValue: Extension) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.modifierExtension) !== 'undefined') {
         delete this.modifierExtension;
      }
      return;
    }
    
    if (typeof(this.modifierExtension) === 'undefined') {
      this.modifierExtension =  [];
    }
    this.modifierExtension.push(newValue);
  }
  /**
  * Removes all elements from the array modifierExtension, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteModifierExtensionAll(): Extension[] {
    if (typeof(this.modifierExtension) !== 'undefined') {
       const oldArray = this.modifierExtension;
       delete this.modifierExtension;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array modifierExtension, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteModifierExtensionBySplice(start: number, deleteCount?: number): Extension[] {
    if (typeof(this.modifierExtension) !== 'undefined') {
       return this.modifierExtension.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field modifierExtension.
  * @returns the value  or undefined
  */
  public getModifierExtension(): Extension[] | undefined {
      return this.modifierExtension;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setContext(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.context) !== 'undefined') {
         delete this.context;
      }
      return;
    }
    
    if (REGEX_CONTEXT.test(newValue)) {
      this.context = newValue
    } else {
      throw new Error("Invalid value pattern for context of " + newValue);
    }
  }
  
  public getContextPattern(): string {
    return REGEX_CONTEXT.source;
  }
  
  /**
  * Gets the current value of field context.
  * @returns the value  or undefined
  */
  public getContext(): string | undefined {
      return this.context;
  }

  /*
  * This sets the data ensuring that the value is valid.  If not valid, it throws an error
  * that should be caught.
  */
  public setContextType(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.contextType) !== 'undefined') {
         delete this.contextType;
      }
      return;
    }
    
    const idx = getValidValueIdx(StructureMapTargetContextType_list_ValidValues, newValue);
    if (idx >= 0) {
      this.contextType = StructureMapTargetContextType_list_ValidValues[idx];
    } else {
      throw new Error("Unknown contextType of " + newValue);
    }
  }
  
  public getStructureMapTargetContextTypeValidValues(): string[] {
    return StructureMapTargetContextType_list_ValidValues;
  }
  
  /**
  * Gets the current value of field contextType.
  * @returns the value  or undefined
  */
  public getContextType(): string | undefined {
      return this.contextType;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setElement(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.element) !== 'undefined') {
         delete this.element;
      }
      return;
    }
    
    if (REGEX_ELEMENT.test(newValue)) {
      this.element = newValue
    } else {
      throw new Error("Invalid value pattern for element of " + newValue);
    }
  }
  
  public getElementPattern(): string {
    return REGEX_ELEMENT.source;
  }
  
  /**
  * Gets the current value of field element.
  * @returns the value  or undefined
  */
  public getElement(): string | undefined {
      return this.element;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setVariable(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.variable) !== 'undefined') {
         delete this.variable;
      }
      return;
    }
    
    if (REGEX_VARIABLE.test(newValue)) {
      this.variable = newValue
    } else {
      throw new Error("Invalid value pattern for variable of " + newValue);
    }
  }
  
  public getVariablePattern(): string {
    return REGEX_VARIABLE.source;
  }
  
  /**
  * Gets the current value of field variable.
  * @returns the value  or undefined
  */
  public getVariable(): string | undefined {
      return this.variable;
  }

  public addListMode(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.listMode) !== 'undefined') {
         delete this.listMode;
      }
      return;
    }
    
    if (typeof(this.listMode) === 'undefined') {
      this.listMode =  [];
    }
    this.listMode.push(newValue);
  }
  /**
  * Removes all elements from the array listMode, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteListModeAll(): string[] {
    if (typeof(this.listMode) !== 'undefined') {
       const oldArray = this.listMode;
       delete this.listMode;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array listMode, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteListModeBySplice(start: number, deleteCount?: number): string[] {
    if (typeof(this.listMode) !== 'undefined') {
       return this.listMode.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field listMode.
  * @returns the value  or undefined
  */
  public getListMode(): string[] | undefined {
      return this.listMode;
  }

  public add_listMode(newValue: Element) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this._listMode) !== 'undefined') {
         delete this._listMode;
      }
      return;
    }
    
    if (typeof(this._listMode) === 'undefined') {
      this._listMode =  [];
    }
    this._listMode.push(newValue);
  }
  /**
  * Removes all elements from the array _listMode, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public delete_listModeAll(): Element[] {
    if (typeof(this._listMode) !== 'undefined') {
       const oldArray = this._listMode;
       delete this._listMode;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array _listMode, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public delete_listModeBySplice(start: number, deleteCount?: number): Element[] {
    if (typeof(this._listMode) !== 'undefined') {
       return this._listMode.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field _listMode.
  * @returns the value  or undefined
  */
  public get_listMode(): Element[] | undefined {
      return this._listMode;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setListRuleId(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.listRuleId) !== 'undefined') {
         delete this.listRuleId;
      }
      return;
    }
    
    if (REGEX_LISTRULEID.test(newValue)) {
      this.listRuleId = newValue
    } else {
      throw new Error("Invalid value pattern for listRuleId of " + newValue);
    }
  }
  
  public getListRuleIdPattern(): string {
    return REGEX_LISTRULEID.source;
  }
  
  /**
  * Gets the current value of field listRuleId.
  * @returns the value  or undefined
  */
  public getListRuleId(): string | undefined {
      return this.listRuleId;
  }

  /*
  * This sets the data ensuring that the value is valid.  If not valid, it throws an error
  * that should be caught.
  */
  public setTransform(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.transform) !== 'undefined') {
         delete this.transform;
      }
      return;
    }
    
    const idx = getValidValueIdx(StructureMapTargetTransform_list_ValidValues, newValue);
    if (idx >= 0) {
      this.transform = StructureMapTargetTransform_list_ValidValues[idx];
    } else {
      throw new Error("Unknown transform of " + newValue);
    }
  }
  
  public getStructureMapTargetTransformValidValues(): string[] {
    return StructureMapTargetTransform_list_ValidValues;
  }
  
  /**
  * Gets the current value of field transform.
  * @returns the value  or undefined
  */
  public getTransform(): string | undefined {
      return this.transform;
  }

  public addParameter(newValue: StructureMapParameter) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.parameter) !== 'undefined') {
         delete this.parameter;
      }
      return;
    }
    
    if (typeof(this.parameter) === 'undefined') {
      this.parameter =  [];
    }
    this.parameter.push(newValue);
  }
  /**
  * Removes all elements from the array parameter, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteParameterAll(): StructureMapParameter[] {
    if (typeof(this.parameter) !== 'undefined') {
       const oldArray = this.parameter;
       delete this.parameter;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array parameter, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteParameterBySplice(start: number, deleteCount?: number): StructureMapParameter[] {
    if (typeof(this.parameter) !== 'undefined') {
       return this.parameter.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field parameter.
  * @returns the value  or undefined
  */
  public getParameter(): StructureMapParameter[] | undefined {
      return this.parameter;
  }


}


