import { Type } from 'class-transformer';
import { REGEX_ID, REGEX_OCCURRENCEDATETIME } from '../FhirTsLibValidation/FhirRegex';
import { Annotation, CodeableConcept, ContractSubject, Element, Extension, Period, Reference, Timing } from './index';



/**
 * Legally enforceable, formally recorded unilateral or bilateral directive i.e., a policy or
 * agreement.
 *
 * Generated by Gallaware, Inc. from:
 *    file:/Users/admin/Documents/DevNetbeans/jsonSchemaToJava/target/classes/schema/fhir.schema.json#/definitions/Contract_Action
 */
export class ContractAction {
  /**
   * A sequence of Unicode characters
   * Field access restricted because there are specific valid values.
   */
  protected id?: string;

  /**
   * May be used to represent additional information that is not part of the basic definition of the
   * element. To make the use of extensions safe and manageable, there is a strict set of governance
   * applied to the definition and use of extensions. Though any implementer can define an extension,
   * there is a set of requirements that SHALL be met as part of the definition of the extension.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Extension)
  protected extension?: Extension[];

  /**
   * May be used to represent additional information that is not part of the basic definition of the
   * element and that modifies the understanding of the element in which it is contained and/or the
   * understanding of the containing element's descendants. Usually modifier elements provide negation
   * or qualification. To make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any implementer can define an
   * extension, there is a set of requirements that SHALL be met as part of the definition of the
   * extension. Applications processing a resource are required to check for modifier extensions.
   * 
   * Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Extension)
  protected modifierExtension?: Extension[];

  /**
   * Value of "true" or "false"
   */
   doNotPerform?: boolean;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _doNotPerform?: Element;

  /**
   * A concept that may be defined by a formal reference to a terminology or ontology or may be provided
   * by text.
   */
  @Type(() => CodeableConcept)
   type?: CodeableConcept;

  /**
   * Entity of the action.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => ContractSubject)
  protected subject?: ContractSubject[];

  /**
   * A concept that may be defined by a formal reference to a terminology or ontology or may be provided
   * by text.
   */
  @Type(() => CodeableConcept)
   intent?: CodeableConcept;

  /**
   * Id [identifier??] of the clause or question text related to this action in the referenced form or
   * QuestionnaireResponse.
   * Field access restricted because there are specific valid values.
   */
  protected linkId?: string[];

  /**
   * Extensions for linkId
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Element)
  protected _linkId?: Element[];

  /**
   * A concept that may be defined by a formal reference to a terminology or ontology or may be provided
   * by text.
   */
  @Type(() => CodeableConcept)
   status?: CodeableConcept;

  /**
   * A reference from one resource to another.
   */
  @Type(() => Reference)
   context?: Reference;

  /**
   * Id [identifier??] of the clause or question text related to the requester of this action in the
   * referenced form or QuestionnaireResponse.
   * Field access restricted because there are specific valid values.
   */
  protected contextLinkId?: string[];

  /**
   * Extensions for contextLinkId
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Element)
  protected _contextLinkId?: Element[];

  /**
   * When action happens.
   * Field access restricted because there are specific valid values.
   */
  protected occurrenceDateTime?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _occurrenceDateTime?: Element;

  /**
   * A time period defined by a start and end date and optionally time.
   */
  @Type(() => Period)
   occurrencePeriod?: Period;

  /**
   * Specifies an event that may occur multiple times. Timing schedules are used to record when things
   * are planned, expected or requested to occur. The most common usage is in dosage instructions for
   * medications. They are also used when planning care of various kinds, and may be used for reporting
   * the schedule to which past regular activities were carried out.
   */
  @Type(() => Timing)
   occurrenceTiming?: Timing;

  /**
   * Who or what initiated the action and has responsibility for its activation.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Reference)
  protected requester?: Reference[];

  /**
   * Id [identifier??] of the clause or question text related to the requester of this action in the
   * referenced form or QuestionnaireResponse.
   * Field access restricted because there are specific valid values.
   */
  protected requesterLinkId?: string[];

  /**
   * Extensions for requesterLinkId
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Element)
  protected _requesterLinkId?: Element[];

  /**
   * The type of individual that is desired or required to perform or not perform the action.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => CodeableConcept)
  protected performerType?: CodeableConcept[];

  /**
   * A concept that may be defined by a formal reference to a terminology or ontology or may be provided
   * by text.
   */
  @Type(() => CodeableConcept)
   performerRole?: CodeableConcept;

  /**
   * A reference from one resource to another.
   */
  @Type(() => Reference)
   performer?: Reference;

  /**
   * Id [identifier??] of the clause or question text related to the reason type or reference of this
   * action in the referenced form or QuestionnaireResponse.
   * Field access restricted because there are specific valid values.
   */
  protected performerLinkId?: string[];

  /**
   * Extensions for performerLinkId
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Element)
  protected _performerLinkId?: Element[];

  /**
   * Rationale for the action to be performed or not performed. Describes why the action is permitted or
   * prohibited.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => CodeableConcept)
  protected reasonCode?: CodeableConcept[];

  /**
   * Indicates another resource whose existence justifies permitting or not permitting this action.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Reference)
  protected reasonReference?: Reference[];

  /**
   * Describes why the action is to be performed or not performed in textual form.
   * Field access restricted because there are specific valid values.
   */
  protected reason?: string[];

  /**
   * Extensions for reason
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Element)
  protected _reason?: Element[];

  /**
   * Id [identifier??] of the clause or question text related to the reason type or reference of this
   * action in the referenced form or QuestionnaireResponse.
   * Field access restricted because there are specific valid values.
   */
  protected reasonLinkId?: string[];

  /**
   * Extensions for reasonLinkId
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Element)
  protected _reasonLinkId?: Element[];

  /**
   * Comments made about the term action made by the requester, performer, subject or other participants.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Annotation)
  protected note?: Annotation[];

  /**
   * Security labels that protects the action.
   * Field access restricted because there are specific valid values.
   */
  protected securityLabelNumber?: number[];

  /**
   * Extensions for securityLabelNumber
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Element)
  protected _securityLabelNumber?: Element[];


  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setId(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.id) !== 'undefined') {
         delete this.id;
      }
      return;
    }
    
    if (REGEX_ID.test(newValue)) {
      this.id = newValue
    } else {
      throw new Error("Invalid value pattern for id of " + newValue);
    }
  }
  
  public getIdPattern(): string {
    return REGEX_ID.source;
  }
  
  /**
  * Gets the current value of field id.
  * @returns the value  or undefined
  */
  public getId(): string | undefined {
      return this.id;
  }

  /**
  * Gets the current value of field id if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getIdOrElse(defaultValue: string): string {
      if (this.id == undefined || this.id == null ) { return defaultValue; }
      return this.id;
  }

  public addExtension(newValue: Extension) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.extension) !== 'undefined') {
         delete this.extension;
      }
      return;
    }
    
    if (typeof(this.extension) === 'undefined') {
      this.extension =  [];
    }
    this.extension.push(newValue);
  }
  /**
  * Removes all elements from the array extension, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteExtensionAll(): Extension[] {
    if (typeof(this.extension) !== 'undefined') {
       const oldArray = this.extension;
       delete this.extension;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array extension, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteExtensionBySplice(start: number, deleteCount?: number): Extension[] {
    if (typeof(this.extension) !== 'undefined') {
       return this.extension.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field extension.
  * @returns the value  or undefined
  */
  public getExtension(): Extension[] | undefined {
      return this.extension;
  }

  /**
  * Gets the current value of field extension if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getExtensionOrElse(defaultValue: Extension[]): Extension[] {
      if (this.extension == undefined || this.extension == null ) { return defaultValue; }
      return this.extension;
  }

  public addModifierExtension(newValue: Extension) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.modifierExtension) !== 'undefined') {
         delete this.modifierExtension;
      }
      return;
    }
    
    if (typeof(this.modifierExtension) === 'undefined') {
      this.modifierExtension =  [];
    }
    this.modifierExtension.push(newValue);
  }
  /**
  * Removes all elements from the array modifierExtension, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteModifierExtensionAll(): Extension[] {
    if (typeof(this.modifierExtension) !== 'undefined') {
       const oldArray = this.modifierExtension;
       delete this.modifierExtension;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array modifierExtension, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteModifierExtensionBySplice(start: number, deleteCount?: number): Extension[] {
    if (typeof(this.modifierExtension) !== 'undefined') {
       return this.modifierExtension.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field modifierExtension.
  * @returns the value  or undefined
  */
  public getModifierExtension(): Extension[] | undefined {
      return this.modifierExtension;
  }

  /**
  * Gets the current value of field modifierExtension if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getModifierExtensionOrElse(defaultValue: Extension[]): Extension[] {
      if (this.modifierExtension == undefined || this.modifierExtension == null ) { return defaultValue; }
      return this.modifierExtension;
  }

  public addSubject(newValue: ContractSubject) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.subject) !== 'undefined') {
         delete this.subject;
      }
      return;
    }
    
    if (typeof(this.subject) === 'undefined') {
      this.subject =  [];
    }
    this.subject.push(newValue);
  }
  /**
  * Removes all elements from the array subject, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteSubjectAll(): ContractSubject[] {
    if (typeof(this.subject) !== 'undefined') {
       const oldArray = this.subject;
       delete this.subject;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array subject, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteSubjectBySplice(start: number, deleteCount?: number): ContractSubject[] {
    if (typeof(this.subject) !== 'undefined') {
       return this.subject.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field subject.
  * @returns the value  or undefined
  */
  public getSubject(): ContractSubject[] | undefined {
      return this.subject;
  }

  /**
  * Gets the current value of field subject if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getSubjectOrElse(defaultValue: ContractSubject[]): ContractSubject[] {
      if (this.subject == undefined || this.subject == null ) { return defaultValue; }
      return this.subject;
  }

  public addLinkId(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.linkId) !== 'undefined') {
         delete this.linkId;
      }
      return;
    }
    
    if (typeof(this.linkId) === 'undefined') {
      this.linkId =  [];
    }
    this.linkId.push(newValue);
  }
  /**
  * Removes all elements from the array linkId, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteLinkIdAll(): string[] {
    if (typeof(this.linkId) !== 'undefined') {
       const oldArray = this.linkId;
       delete this.linkId;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array linkId, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteLinkIdBySplice(start: number, deleteCount?: number): string[] {
    if (typeof(this.linkId) !== 'undefined') {
       return this.linkId.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field linkId.
  * @returns the value  or undefined
  */
  public getLinkId(): string[] | undefined {
      return this.linkId;
  }

  /**
  * Gets the current value of field linkId if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getLinkIdOrElse(defaultValue: string[]): string[] {
      if (this.linkId == undefined || this.linkId == null ) { return defaultValue; }
      return this.linkId;
  }

  public add_linkId(newValue: Element) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this._linkId) !== 'undefined') {
         delete this._linkId;
      }
      return;
    }
    
    if (typeof(this._linkId) === 'undefined') {
      this._linkId =  [];
    }
    this._linkId.push(newValue);
  }
  /**
  * Removes all elements from the array _linkId, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public delete_linkIdAll(): Element[] {
    if (typeof(this._linkId) !== 'undefined') {
       const oldArray = this._linkId;
       delete this._linkId;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array _linkId, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public delete_linkIdBySplice(start: number, deleteCount?: number): Element[] {
    if (typeof(this._linkId) !== 'undefined') {
       return this._linkId.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field _linkId.
  * @returns the value  or undefined
  */
  public get_linkId(): Element[] | undefined {
      return this._linkId;
  }

  /**
  * Gets the current value of field _linkId if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public get_linkIdOrElse(defaultValue: Element[]): Element[] {
      if (this._linkId == undefined || this._linkId == null ) { return defaultValue; }
      return this._linkId;
  }

  public addContextLinkId(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.contextLinkId) !== 'undefined') {
         delete this.contextLinkId;
      }
      return;
    }
    
    if (typeof(this.contextLinkId) === 'undefined') {
      this.contextLinkId =  [];
    }
    this.contextLinkId.push(newValue);
  }
  /**
  * Removes all elements from the array contextLinkId, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteContextLinkIdAll(): string[] {
    if (typeof(this.contextLinkId) !== 'undefined') {
       const oldArray = this.contextLinkId;
       delete this.contextLinkId;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array contextLinkId, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteContextLinkIdBySplice(start: number, deleteCount?: number): string[] {
    if (typeof(this.contextLinkId) !== 'undefined') {
       return this.contextLinkId.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field contextLinkId.
  * @returns the value  or undefined
  */
  public getContextLinkId(): string[] | undefined {
      return this.contextLinkId;
  }

  /**
  * Gets the current value of field contextLinkId if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getContextLinkIdOrElse(defaultValue: string[]): string[] {
      if (this.contextLinkId == undefined || this.contextLinkId == null ) { return defaultValue; }
      return this.contextLinkId;
  }

  public add_contextLinkId(newValue: Element) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this._contextLinkId) !== 'undefined') {
         delete this._contextLinkId;
      }
      return;
    }
    
    if (typeof(this._contextLinkId) === 'undefined') {
      this._contextLinkId =  [];
    }
    this._contextLinkId.push(newValue);
  }
  /**
  * Removes all elements from the array _contextLinkId, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public delete_contextLinkIdAll(): Element[] {
    if (typeof(this._contextLinkId) !== 'undefined') {
       const oldArray = this._contextLinkId;
       delete this._contextLinkId;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array _contextLinkId, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public delete_contextLinkIdBySplice(start: number, deleteCount?: number): Element[] {
    if (typeof(this._contextLinkId) !== 'undefined') {
       return this._contextLinkId.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field _contextLinkId.
  * @returns the value  or undefined
  */
  public get_contextLinkId(): Element[] | undefined {
      return this._contextLinkId;
  }

  /**
  * Gets the current value of field _contextLinkId if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public get_contextLinkIdOrElse(defaultValue: Element[]): Element[] {
      if (this._contextLinkId == undefined || this._contextLinkId == null ) { return defaultValue; }
      return this._contextLinkId;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setOccurrenceDateTime(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.occurrenceDateTime) !== 'undefined') {
         delete this.occurrenceDateTime;
      }
      return;
    }
    
    if (REGEX_OCCURRENCEDATETIME.test(newValue)) {
      this.occurrenceDateTime = newValue
    } else {
      throw new Error("Invalid value pattern for occurrenceDateTime of " + newValue);
    }
  }
  
  public getOccurrenceDateTimePattern(): string {
    return REGEX_OCCURRENCEDATETIME.source;
  }
  
  /**
  * Gets the current value of field occurrenceDateTime.
  * @returns the value  or undefined
  */
  public getOccurrenceDateTime(): string | undefined {
      return this.occurrenceDateTime;
  }

  /**
  * Gets the current value of field occurrenceDateTime if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getOccurrenceDateTimeOrElse(defaultValue: string): string {
      if (this.occurrenceDateTime == undefined || this.occurrenceDateTime == null ) { return defaultValue; }
      return this.occurrenceDateTime;
  }

  public addRequester(newValue: Reference) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.requester) !== 'undefined') {
         delete this.requester;
      }
      return;
    }
    
    if (typeof(this.requester) === 'undefined') {
      this.requester =  [];
    }
    this.requester.push(newValue);
  }
  /**
  * Removes all elements from the array requester, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteRequesterAll(): Reference[] {
    if (typeof(this.requester) !== 'undefined') {
       const oldArray = this.requester;
       delete this.requester;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array requester, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteRequesterBySplice(start: number, deleteCount?: number): Reference[] {
    if (typeof(this.requester) !== 'undefined') {
       return this.requester.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field requester.
  * @returns the value  or undefined
  */
  public getRequester(): Reference[] | undefined {
      return this.requester;
  }

  /**
  * Gets the current value of field requester if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getRequesterOrElse(defaultValue: Reference[]): Reference[] {
      if (this.requester == undefined || this.requester == null ) { return defaultValue; }
      return this.requester;
  }

  public addRequesterLinkId(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.requesterLinkId) !== 'undefined') {
         delete this.requesterLinkId;
      }
      return;
    }
    
    if (typeof(this.requesterLinkId) === 'undefined') {
      this.requesterLinkId =  [];
    }
    this.requesterLinkId.push(newValue);
  }
  /**
  * Removes all elements from the array requesterLinkId, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteRequesterLinkIdAll(): string[] {
    if (typeof(this.requesterLinkId) !== 'undefined') {
       const oldArray = this.requesterLinkId;
       delete this.requesterLinkId;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array requesterLinkId, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteRequesterLinkIdBySplice(start: number, deleteCount?: number): string[] {
    if (typeof(this.requesterLinkId) !== 'undefined') {
       return this.requesterLinkId.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field requesterLinkId.
  * @returns the value  or undefined
  */
  public getRequesterLinkId(): string[] | undefined {
      return this.requesterLinkId;
  }

  /**
  * Gets the current value of field requesterLinkId if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getRequesterLinkIdOrElse(defaultValue: string[]): string[] {
      if (this.requesterLinkId == undefined || this.requesterLinkId == null ) { return defaultValue; }
      return this.requesterLinkId;
  }

  public add_requesterLinkId(newValue: Element) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this._requesterLinkId) !== 'undefined') {
         delete this._requesterLinkId;
      }
      return;
    }
    
    if (typeof(this._requesterLinkId) === 'undefined') {
      this._requesterLinkId =  [];
    }
    this._requesterLinkId.push(newValue);
  }
  /**
  * Removes all elements from the array _requesterLinkId, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public delete_requesterLinkIdAll(): Element[] {
    if (typeof(this._requesterLinkId) !== 'undefined') {
       const oldArray = this._requesterLinkId;
       delete this._requesterLinkId;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array _requesterLinkId, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public delete_requesterLinkIdBySplice(start: number, deleteCount?: number): Element[] {
    if (typeof(this._requesterLinkId) !== 'undefined') {
       return this._requesterLinkId.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field _requesterLinkId.
  * @returns the value  or undefined
  */
  public get_requesterLinkId(): Element[] | undefined {
      return this._requesterLinkId;
  }

  /**
  * Gets the current value of field _requesterLinkId if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public get_requesterLinkIdOrElse(defaultValue: Element[]): Element[] {
      if (this._requesterLinkId == undefined || this._requesterLinkId == null ) { return defaultValue; }
      return this._requesterLinkId;
  }

  public addPerformerType(newValue: CodeableConcept) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.performerType) !== 'undefined') {
         delete this.performerType;
      }
      return;
    }
    
    if (typeof(this.performerType) === 'undefined') {
      this.performerType =  [];
    }
    this.performerType.push(newValue);
  }
  /**
  * Removes all elements from the array performerType, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deletePerformerTypeAll(): CodeableConcept[] {
    if (typeof(this.performerType) !== 'undefined') {
       const oldArray = this.performerType;
       delete this.performerType;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array performerType, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deletePerformerTypeBySplice(start: number, deleteCount?: number): CodeableConcept[] {
    if (typeof(this.performerType) !== 'undefined') {
       return this.performerType.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field performerType.
  * @returns the value  or undefined
  */
  public getPerformerType(): CodeableConcept[] | undefined {
      return this.performerType;
  }

  /**
  * Gets the current value of field performerType if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getPerformerTypeOrElse(defaultValue: CodeableConcept[]): CodeableConcept[] {
      if (this.performerType == undefined || this.performerType == null ) { return defaultValue; }
      return this.performerType;
  }

  public addPerformerLinkId(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.performerLinkId) !== 'undefined') {
         delete this.performerLinkId;
      }
      return;
    }
    
    if (typeof(this.performerLinkId) === 'undefined') {
      this.performerLinkId =  [];
    }
    this.performerLinkId.push(newValue);
  }
  /**
  * Removes all elements from the array performerLinkId, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deletePerformerLinkIdAll(): string[] {
    if (typeof(this.performerLinkId) !== 'undefined') {
       const oldArray = this.performerLinkId;
       delete this.performerLinkId;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array performerLinkId, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deletePerformerLinkIdBySplice(start: number, deleteCount?: number): string[] {
    if (typeof(this.performerLinkId) !== 'undefined') {
       return this.performerLinkId.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field performerLinkId.
  * @returns the value  or undefined
  */
  public getPerformerLinkId(): string[] | undefined {
      return this.performerLinkId;
  }

  /**
  * Gets the current value of field performerLinkId if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getPerformerLinkIdOrElse(defaultValue: string[]): string[] {
      if (this.performerLinkId == undefined || this.performerLinkId == null ) { return defaultValue; }
      return this.performerLinkId;
  }

  public add_performerLinkId(newValue: Element) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this._performerLinkId) !== 'undefined') {
         delete this._performerLinkId;
      }
      return;
    }
    
    if (typeof(this._performerLinkId) === 'undefined') {
      this._performerLinkId =  [];
    }
    this._performerLinkId.push(newValue);
  }
  /**
  * Removes all elements from the array _performerLinkId, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public delete_performerLinkIdAll(): Element[] {
    if (typeof(this._performerLinkId) !== 'undefined') {
       const oldArray = this._performerLinkId;
       delete this._performerLinkId;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array _performerLinkId, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public delete_performerLinkIdBySplice(start: number, deleteCount?: number): Element[] {
    if (typeof(this._performerLinkId) !== 'undefined') {
       return this._performerLinkId.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field _performerLinkId.
  * @returns the value  or undefined
  */
  public get_performerLinkId(): Element[] | undefined {
      return this._performerLinkId;
  }

  /**
  * Gets the current value of field _performerLinkId if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public get_performerLinkIdOrElse(defaultValue: Element[]): Element[] {
      if (this._performerLinkId == undefined || this._performerLinkId == null ) { return defaultValue; }
      return this._performerLinkId;
  }

  public addReasonCode(newValue: CodeableConcept) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.reasonCode) !== 'undefined') {
         delete this.reasonCode;
      }
      return;
    }
    
    if (typeof(this.reasonCode) === 'undefined') {
      this.reasonCode =  [];
    }
    this.reasonCode.push(newValue);
  }
  /**
  * Removes all elements from the array reasonCode, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteReasonCodeAll(): CodeableConcept[] {
    if (typeof(this.reasonCode) !== 'undefined') {
       const oldArray = this.reasonCode;
       delete this.reasonCode;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array reasonCode, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteReasonCodeBySplice(start: number, deleteCount?: number): CodeableConcept[] {
    if (typeof(this.reasonCode) !== 'undefined') {
       return this.reasonCode.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field reasonCode.
  * @returns the value  or undefined
  */
  public getReasonCode(): CodeableConcept[] | undefined {
      return this.reasonCode;
  }

  /**
  * Gets the current value of field reasonCode if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getReasonCodeOrElse(defaultValue: CodeableConcept[]): CodeableConcept[] {
      if (this.reasonCode == undefined || this.reasonCode == null ) { return defaultValue; }
      return this.reasonCode;
  }

  public addReasonReference(newValue: Reference) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.reasonReference) !== 'undefined') {
         delete this.reasonReference;
      }
      return;
    }
    
    if (typeof(this.reasonReference) === 'undefined') {
      this.reasonReference =  [];
    }
    this.reasonReference.push(newValue);
  }
  /**
  * Removes all elements from the array reasonReference, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteReasonReferenceAll(): Reference[] {
    if (typeof(this.reasonReference) !== 'undefined') {
       const oldArray = this.reasonReference;
       delete this.reasonReference;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array reasonReference, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteReasonReferenceBySplice(start: number, deleteCount?: number): Reference[] {
    if (typeof(this.reasonReference) !== 'undefined') {
       return this.reasonReference.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field reasonReference.
  * @returns the value  or undefined
  */
  public getReasonReference(): Reference[] | undefined {
      return this.reasonReference;
  }

  /**
  * Gets the current value of field reasonReference if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getReasonReferenceOrElse(defaultValue: Reference[]): Reference[] {
      if (this.reasonReference == undefined || this.reasonReference == null ) { return defaultValue; }
      return this.reasonReference;
  }

  public addReason(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.reason) !== 'undefined') {
         delete this.reason;
      }
      return;
    }
    
    if (typeof(this.reason) === 'undefined') {
      this.reason =  [];
    }
    this.reason.push(newValue);
  }
  /**
  * Removes all elements from the array reason, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteReasonAll(): string[] {
    if (typeof(this.reason) !== 'undefined') {
       const oldArray = this.reason;
       delete this.reason;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array reason, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteReasonBySplice(start: number, deleteCount?: number): string[] {
    if (typeof(this.reason) !== 'undefined') {
       return this.reason.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field reason.
  * @returns the value  or undefined
  */
  public getReason(): string[] | undefined {
      return this.reason;
  }

  /**
  * Gets the current value of field reason if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getReasonOrElse(defaultValue: string[]): string[] {
      if (this.reason == undefined || this.reason == null ) { return defaultValue; }
      return this.reason;
  }

  public add_reason(newValue: Element) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this._reason) !== 'undefined') {
         delete this._reason;
      }
      return;
    }
    
    if (typeof(this._reason) === 'undefined') {
      this._reason =  [];
    }
    this._reason.push(newValue);
  }
  /**
  * Removes all elements from the array _reason, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public delete_reasonAll(): Element[] {
    if (typeof(this._reason) !== 'undefined') {
       const oldArray = this._reason;
       delete this._reason;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array _reason, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public delete_reasonBySplice(start: number, deleteCount?: number): Element[] {
    if (typeof(this._reason) !== 'undefined') {
       return this._reason.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field _reason.
  * @returns the value  or undefined
  */
  public get_reason(): Element[] | undefined {
      return this._reason;
  }

  /**
  * Gets the current value of field _reason if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public get_reasonOrElse(defaultValue: Element[]): Element[] {
      if (this._reason == undefined || this._reason == null ) { return defaultValue; }
      return this._reason;
  }

  public addReasonLinkId(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.reasonLinkId) !== 'undefined') {
         delete this.reasonLinkId;
      }
      return;
    }
    
    if (typeof(this.reasonLinkId) === 'undefined') {
      this.reasonLinkId =  [];
    }
    this.reasonLinkId.push(newValue);
  }
  /**
  * Removes all elements from the array reasonLinkId, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteReasonLinkIdAll(): string[] {
    if (typeof(this.reasonLinkId) !== 'undefined') {
       const oldArray = this.reasonLinkId;
       delete this.reasonLinkId;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array reasonLinkId, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteReasonLinkIdBySplice(start: number, deleteCount?: number): string[] {
    if (typeof(this.reasonLinkId) !== 'undefined') {
       return this.reasonLinkId.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field reasonLinkId.
  * @returns the value  or undefined
  */
  public getReasonLinkId(): string[] | undefined {
      return this.reasonLinkId;
  }

  /**
  * Gets the current value of field reasonLinkId if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getReasonLinkIdOrElse(defaultValue: string[]): string[] {
      if (this.reasonLinkId == undefined || this.reasonLinkId == null ) { return defaultValue; }
      return this.reasonLinkId;
  }

  public add_reasonLinkId(newValue: Element) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this._reasonLinkId) !== 'undefined') {
         delete this._reasonLinkId;
      }
      return;
    }
    
    if (typeof(this._reasonLinkId) === 'undefined') {
      this._reasonLinkId =  [];
    }
    this._reasonLinkId.push(newValue);
  }
  /**
  * Removes all elements from the array _reasonLinkId, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public delete_reasonLinkIdAll(): Element[] {
    if (typeof(this._reasonLinkId) !== 'undefined') {
       const oldArray = this._reasonLinkId;
       delete this._reasonLinkId;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array _reasonLinkId, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public delete_reasonLinkIdBySplice(start: number, deleteCount?: number): Element[] {
    if (typeof(this._reasonLinkId) !== 'undefined') {
       return this._reasonLinkId.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field _reasonLinkId.
  * @returns the value  or undefined
  */
  public get_reasonLinkId(): Element[] | undefined {
      return this._reasonLinkId;
  }

  /**
  * Gets the current value of field _reasonLinkId if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public get_reasonLinkIdOrElse(defaultValue: Element[]): Element[] {
      if (this._reasonLinkId == undefined || this._reasonLinkId == null ) { return defaultValue; }
      return this._reasonLinkId;
  }

  public addNote(newValue: Annotation) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.note) !== 'undefined') {
         delete this.note;
      }
      return;
    }
    
    if (typeof(this.note) === 'undefined') {
      this.note =  [];
    }
    this.note.push(newValue);
  }
  /**
  * Removes all elements from the array note, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteNoteAll(): Annotation[] {
    if (typeof(this.note) !== 'undefined') {
       const oldArray = this.note;
       delete this.note;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array note, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteNoteBySplice(start: number, deleteCount?: number): Annotation[] {
    if (typeof(this.note) !== 'undefined') {
       return this.note.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field note.
  * @returns the value  or undefined
  */
  public getNote(): Annotation[] | undefined {
      return this.note;
  }

  /**
  * Gets the current value of field note if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getNoteOrElse(defaultValue: Annotation[]): Annotation[] {
      if (this.note == undefined || this.note == null ) { return defaultValue; }
      return this.note;
  }

  public addSecurityLabelNumber(newValue: number) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.securityLabelNumber) !== 'undefined') {
         delete this.securityLabelNumber;
      }
      return;
    }
    
    if (typeof(this.securityLabelNumber) === 'undefined') {
      this.securityLabelNumber =  [];
    }
    this.securityLabelNumber.push(newValue);
  }
  /**
  * Removes all elements from the array securityLabelNumber, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteSecurityLabelNumberAll(): number[] {
    if (typeof(this.securityLabelNumber) !== 'undefined') {
       const oldArray = this.securityLabelNumber;
       delete this.securityLabelNumber;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array securityLabelNumber, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteSecurityLabelNumberBySplice(start: number, deleteCount?: number): number[] {
    if (typeof(this.securityLabelNumber) !== 'undefined') {
       return this.securityLabelNumber.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field securityLabelNumber.
  * @returns the value  or undefined
  */
  public getSecurityLabelNumber(): number[] | undefined {
      return this.securityLabelNumber;
  }

  /**
  * Gets the current value of field securityLabelNumber if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getSecurityLabelNumberOrElse(defaultValue: number[]): number[] {
      if (this.securityLabelNumber == undefined || this.securityLabelNumber == null ) { return defaultValue; }
      return this.securityLabelNumber;
  }

  public add_securityLabelNumber(newValue: Element) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this._securityLabelNumber) !== 'undefined') {
         delete this._securityLabelNumber;
      }
      return;
    }
    
    if (typeof(this._securityLabelNumber) === 'undefined') {
      this._securityLabelNumber =  [];
    }
    this._securityLabelNumber.push(newValue);
  }
  /**
  * Removes all elements from the array _securityLabelNumber, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public delete_securityLabelNumberAll(): Element[] {
    if (typeof(this._securityLabelNumber) !== 'undefined') {
       const oldArray = this._securityLabelNumber;
       delete this._securityLabelNumber;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array _securityLabelNumber, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public delete_securityLabelNumberBySplice(start: number, deleteCount?: number): Element[] {
    if (typeof(this._securityLabelNumber) !== 'undefined') {
       return this._securityLabelNumber.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field _securityLabelNumber.
  * @returns the value  or undefined
  */
  public get_securityLabelNumber(): Element[] | undefined {
      return this._securityLabelNumber;
  }

  /**
  * Gets the current value of field _securityLabelNumber if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public get_securityLabelNumberOrElse(defaultValue: Element[]): Element[] {
      if (this._securityLabelNumber == undefined || this._securityLabelNumber == null ) { return defaultValue; }
      return this._securityLabelNumber;
  }


}


