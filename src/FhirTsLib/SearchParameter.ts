import { getValidValueIdx } from '../FhirTsLibValidation/FhirUtils';
import { Type } from 'class-transformer';
import { REGEX_ID_000, REGEX_IMPLICITRULES, REGEX_LANGUAGE, REGEX_URL, REGEX_VERSION, REGEX_NAME, REGEX_DERIVEDFROM, REGEX_DATE, REGEX_PUBLISHER, REGEX_DESCRIPTION, REGEX_PURPOSE, REGEX_CODE, REGEX_EXPRESSION, REGEX_XPATH } from '../FhirTsLibValidation/FhirRegex';
import { CodeableConcept, ContactDetail, Element, Extension, Meta, Narrative, ResourceList, Account, ActivityDefinition, AdverseEvent, AllergyIntolerance, Appointment, AppointmentResponse, AuditEvent, Basic, Binary, BiologicallyDerivedProduct, BodyStructure, Bundle, CapabilityStatement, CarePlan, CareTeam, CatalogEntry, ChargeItem, ChargeItemDefinition, Claim, ClaimResponse, ClinicalImpression, CodeSystem, Communication, CommunicationRequest, CompartmentDefinition, Composition, ConceptMap, Condition, Consent, Contract, Coverage, CoverageEligibilityRequest, CoverageEligibilityResponse, DetectedIssue, Device, DeviceDefinition, DeviceMetric, DeviceRequest, DeviceUseStatement, DiagnosticReport, DocumentManifest, DocumentReference, EffectEvidenceSynthesis, Encounter, Endpoint, EnrollmentRequest, EnrollmentResponse, EpisodeOfCare, EventDefinition, Evidence, EvidenceVariable, ExampleScenario, ExplanationOfBenefit, FamilyMemberHistory, Flag, Goal, GraphDefinition, Group, GuidanceResponse, HealthcareService, ImagingStudy, Immunization, ImmunizationEvaluation, ImmunizationRecommendation, ImplementationGuide, InsurancePlan, Invoice, Library, Linkage, List, Location, Measure, MeasureReport, Media, Medication, MedicationAdministration, MedicationDispense, MedicationKnowledge, MedicationRequest, MedicationStatement, MedicinalProduct, MedicinalProductAuthorization, MedicinalProductContraindication, MedicinalProductIndication, MedicinalProductIngredient, MedicinalProductInteraction, MedicinalProductManufactured, MedicinalProductPackaged, MedicinalProductPharmaceutical, MedicinalProductUndesirableEffect, MessageDefinition, MessageHeader, MolecularSequence, NamingSystem, NutritionOrder, Observation, ObservationDefinition, OperationDefinition, OperationOutcome, Organization, OrganizationAffiliation, Parameters, Patient, PaymentNotice, PaymentReconciliation, Person, PlanDefinition, Practitioner, PractitionerRole, Procedure, Provenance, Questionnaire, QuestionnaireResponse, RelatedPerson, RequestGroup, ResearchDefinition, ResearchElementDefinition, ResearchStudy, ResearchSubject, RiskAssessment, RiskEvidenceSynthesis, Schedule, ServiceRequest, Slot, Specimen, SpecimenDefinition, StructureDefinition, StructureMap, Subscription, Substance, SubstanceNucleicAcid, SubstancePolymer, SubstanceProtein, SubstanceReferenceInformation, SubstanceSourceMaterial, SubstanceSpecification, SupplyDelivery, SupplyRequest, Task, TerminologyCapabilities, TestReport, TestScript, ValueSet, VerificationResult, VisionPrescription, SearchParameterComponent, UsageContext } from './index';
import { SearchParameterStatus_list_ValidValues, SearchParameterType_list_ValidValues, SearchParameterXpathUsage_list_ValidValues } from '../FhirTsLibValidation/Fhir_ValidValues';



/**
 * A search parameter that defines a named search item that can be used to search/filter on a resource.
 *
 * Generated by Gallaware, Inc. from:
 *    file:/Users/admin/Documents/DevNetbeans/jsonSchemaToJava/target/classes/schema/fhir.schema.json#/definitions/SearchParameter
 */
export class SearchParameter {
  /**
   * This is a SearchParameter resource
   */
     resourceType = "SearchParameter";

  /**
   * Any combination of letters, numerals, "-" and ".", with a length limit of 64 characters.  (This
   * might be an integer, an unprefixed OID, UUID or any other identifier pattern that meets these
   * constraints.)  Ids are case-insensitive.
   * Field access restricted because there are specific valid values.
   */
  protected id?: string;

  /**
   * The metadata about a resource. This is content in the resource that is maintained by the
   * infrastructure. Changes to the content might not always be associated with version changes to the
   * resource.
   */
  @Type(() => Meta)
   meta?: Meta;

  /**
   * String of characters used to identify a name or a resource
   * Field access restricted because there are specific valid values.
   */
  protected implicitRules?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _implicitRules?: Element;

  /**
   * A string which has at least one character and no leading or trailing whitespace and where there is
   * no whitespace other than single spaces in the contents
   * Field access restricted because there are specific valid values.
   */
  protected language?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _language?: Element;

  /**
   * A human-readable summary of the resource conveying the essential clinical and business information
   * for the resource.
   */
  @Type(() => Narrative)
   text?: Narrative;

  /**
   * These resources do not have an independent existence apart from the resource that contains them -
   * they cannot be identified independently, and nor can they have their own independent transaction
   * scope.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => ResourceList, {
          discriminator: {
    property: 'resourceType',
    subTypes: [
      	{ value: Account, name: 'Account'},
      	{ value: ActivityDefinition, name: 'ActivityDefinition'},
      	{ value: AdverseEvent, name: 'AdverseEvent'},
      	{ value: AllergyIntolerance, name: 'AllergyIntolerance'},
      	{ value: Appointment, name: 'Appointment'},
      	{ value: AppointmentResponse, name: 'AppointmentResponse'},
      	{ value: AuditEvent, name: 'AuditEvent'},
      	{ value: Basic, name: 'Basic'},
      	{ value: Binary, name: 'Binary'},
      	{ value: BiologicallyDerivedProduct, name: 'BiologicallyDerivedProduct'},
      	{ value: BodyStructure, name: 'BodyStructure'},
      	{ value: Bundle, name: 'Bundle'},
      	{ value: CapabilityStatement, name: 'CapabilityStatement'},
      	{ value: CarePlan, name: 'CarePlan'},
      	{ value: CareTeam, name: 'CareTeam'},
      	{ value: CatalogEntry, name: 'CatalogEntry'},
      	{ value: ChargeItem, name: 'ChargeItem'},
      	{ value: ChargeItemDefinition, name: 'ChargeItemDefinition'},
      	{ value: Claim, name: 'Claim'},
      	{ value: ClaimResponse, name: 'ClaimResponse'},
      	{ value: ClinicalImpression, name: 'ClinicalImpression'},
      	{ value: CodeSystem, name: 'CodeSystem'},
      	{ value: Communication, name: 'Communication'},
      	{ value: CommunicationRequest, name: 'CommunicationRequest'},
      	{ value: CompartmentDefinition, name: 'CompartmentDefinition'},
      	{ value: Composition, name: 'Composition'},
      	{ value: ConceptMap, name: 'ConceptMap'},
      	{ value: Condition, name: 'Condition'},
      	{ value: Consent, name: 'Consent'},
      	{ value: Contract, name: 'Contract'},
      	{ value: Coverage, name: 'Coverage'},
      	{ value: CoverageEligibilityRequest, name: 'CoverageEligibilityRequest'},
      	{ value: CoverageEligibilityResponse, name: 'CoverageEligibilityResponse'},
      	{ value: DetectedIssue, name: 'DetectedIssue'},
      	{ value: Device, name: 'Device'},
      	{ value: DeviceDefinition, name: 'DeviceDefinition'},
      	{ value: DeviceMetric, name: 'DeviceMetric'},
      	{ value: DeviceRequest, name: 'DeviceRequest'},
      	{ value: DeviceUseStatement, name: 'DeviceUseStatement'},
      	{ value: DiagnosticReport, name: 'DiagnosticReport'},
      	{ value: DocumentManifest, name: 'DocumentManifest'},
      	{ value: DocumentReference, name: 'DocumentReference'},
      	{ value: EffectEvidenceSynthesis, name: 'EffectEvidenceSynthesis'},
      	{ value: Encounter, name: 'Encounter'},
      	{ value: Endpoint, name: 'Endpoint'},
      	{ value: EnrollmentRequest, name: 'EnrollmentRequest'},
      	{ value: EnrollmentResponse, name: 'EnrollmentResponse'},
      	{ value: EpisodeOfCare, name: 'EpisodeOfCare'},
      	{ value: EventDefinition, name: 'EventDefinition'},
      	{ value: Evidence, name: 'Evidence'},
      	{ value: EvidenceVariable, name: 'EvidenceVariable'},
      	{ value: ExampleScenario, name: 'ExampleScenario'},
      	{ value: ExplanationOfBenefit, name: 'ExplanationOfBenefit'},
      	{ value: FamilyMemberHistory, name: 'FamilyMemberHistory'},
      	{ value: Flag, name: 'Flag'},
      	{ value: Goal, name: 'Goal'},
      	{ value: GraphDefinition, name: 'GraphDefinition'},
      	{ value: Group, name: 'Group'},
      	{ value: GuidanceResponse, name: 'GuidanceResponse'},
      	{ value: HealthcareService, name: 'HealthcareService'},
      	{ value: ImagingStudy, name: 'ImagingStudy'},
      	{ value: Immunization, name: 'Immunization'},
      	{ value: ImmunizationEvaluation, name: 'ImmunizationEvaluation'},
      	{ value: ImmunizationRecommendation, name: 'ImmunizationRecommendation'},
      	{ value: ImplementationGuide, name: 'ImplementationGuide'},
      	{ value: InsurancePlan, name: 'InsurancePlan'},
      	{ value: Invoice, name: 'Invoice'},
      	{ value: Library, name: 'Library'},
      	{ value: Linkage, name: 'Linkage'},
      	{ value: List, name: 'List'},
      	{ value: Location, name: 'Location'},
      	{ value: Measure, name: 'Measure'},
      	{ value: MeasureReport, name: 'MeasureReport'},
      	{ value: Media, name: 'Media'},
      	{ value: Medication, name: 'Medication'},
      	{ value: MedicationAdministration, name: 'MedicationAdministration'},
      	{ value: MedicationDispense, name: 'MedicationDispense'},
      	{ value: MedicationKnowledge, name: 'MedicationKnowledge'},
      	{ value: MedicationRequest, name: 'MedicationRequest'},
      	{ value: MedicationStatement, name: 'MedicationStatement'},
      	{ value: MedicinalProduct, name: 'MedicinalProduct'},
      	{ value: MedicinalProductAuthorization, name: 'MedicinalProductAuthorization'},
      	{ value: MedicinalProductContraindication, name: 'MedicinalProductContraindication'},
      	{ value: MedicinalProductIndication, name: 'MedicinalProductIndication'},
      	{ value: MedicinalProductIngredient, name: 'MedicinalProductIngredient'},
      	{ value: MedicinalProductInteraction, name: 'MedicinalProductInteraction'},
      	{ value: MedicinalProductManufactured, name: 'MedicinalProductManufactured'},
      	{ value: MedicinalProductPackaged, name: 'MedicinalProductPackaged'},
      	{ value: MedicinalProductPharmaceutical, name: 'MedicinalProductPharmaceutical'},
      	{ value: MedicinalProductUndesirableEffect, name: 'MedicinalProductUndesirableEffect'},
      	{ value: MessageDefinition, name: 'MessageDefinition'},
      	{ value: MessageHeader, name: 'MessageHeader'},
      	{ value: MolecularSequence, name: 'MolecularSequence'},
      	{ value: NamingSystem, name: 'NamingSystem'},
      	{ value: NutritionOrder, name: 'NutritionOrder'},
      	{ value: Observation, name: 'Observation'},
      	{ value: ObservationDefinition, name: 'ObservationDefinition'},
      	{ value: OperationDefinition, name: 'OperationDefinition'},
      	{ value: OperationOutcome, name: 'OperationOutcome'},
      	{ value: Organization, name: 'Organization'},
      	{ value: OrganizationAffiliation, name: 'OrganizationAffiliation'},
      	{ value: Parameters, name: 'Parameters'},
      	{ value: Patient, name: 'Patient'},
      	{ value: PaymentNotice, name: 'PaymentNotice'},
      	{ value: PaymentReconciliation, name: 'PaymentReconciliation'},
      	{ value: Person, name: 'Person'},
      	{ value: PlanDefinition, name: 'PlanDefinition'},
      	{ value: Practitioner, name: 'Practitioner'},
      	{ value: PractitionerRole, name: 'PractitionerRole'},
      	{ value: Procedure, name: 'Procedure'},
      	{ value: Provenance, name: 'Provenance'},
      	{ value: Questionnaire, name: 'Questionnaire'},
      	{ value: QuestionnaireResponse, name: 'QuestionnaireResponse'},
      	{ value: RelatedPerson, name: 'RelatedPerson'},
      	{ value: RequestGroup, name: 'RequestGroup'},
      	{ value: ResearchDefinition, name: 'ResearchDefinition'},
      	{ value: ResearchElementDefinition, name: 'ResearchElementDefinition'},
      	{ value: ResearchStudy, name: 'ResearchStudy'},
      	{ value: ResearchSubject, name: 'ResearchSubject'},
      	{ value: RiskAssessment, name: 'RiskAssessment'},
      	{ value: RiskEvidenceSynthesis, name: 'RiskEvidenceSynthesis'},
      	{ value: Schedule, name: 'Schedule'},
      	{ value: SearchParameter, name: 'SearchParameter'},
      	{ value: ServiceRequest, name: 'ServiceRequest'},
      	{ value: Slot, name: 'Slot'},
      	{ value: Specimen, name: 'Specimen'},
      	{ value: SpecimenDefinition, name: 'SpecimenDefinition'},
      	{ value: StructureDefinition, name: 'StructureDefinition'},
      	{ value: StructureMap, name: 'StructureMap'},
      	{ value: Subscription, name: 'Subscription'},
      	{ value: Substance, name: 'Substance'},
      	{ value: SubstanceNucleicAcid, name: 'SubstanceNucleicAcid'},
      	{ value: SubstancePolymer, name: 'SubstancePolymer'},
      	{ value: SubstanceProtein, name: 'SubstanceProtein'},
      	{ value: SubstanceReferenceInformation, name: 'SubstanceReferenceInformation'},
      	{ value: SubstanceSourceMaterial, name: 'SubstanceSourceMaterial'},
      	{ value: SubstanceSpecification, name: 'SubstanceSpecification'},
      	{ value: SupplyDelivery, name: 'SupplyDelivery'},
      	{ value: SupplyRequest, name: 'SupplyRequest'},
      	{ value: Task, name: 'Task'},
      	{ value: TerminologyCapabilities, name: 'TerminologyCapabilities'},
      	{ value: TestReport, name: 'TestReport'},
      	{ value: TestScript, name: 'TestScript'},
      	{ value: ValueSet, name: 'ValueSet'},
      	{ value: VerificationResult, name: 'VerificationResult'},
      	{ value: VisionPrescription, name: 'VisionPrescription'}
      ],
    }
  })
  protected contained?: ResourceList[];

  /**
   * May be used to represent additional information that is not part of the basic definition of the
   * resource. To make the use of extensions safe and manageable, there is a strict set of governance
   * applied to the definition and use of extensions. Though any implementer can define an extension,
   * there is a set of requirements that SHALL be met as part of the definition of the extension.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Extension)
  protected extension?: Extension[];

  /**
   * May be used to represent additional information that is not part of the basic definition of the
   * resource and that modifies the understanding of the element that contains it and/or the
   * understanding of the containing element's descendants. Usually modifier elements provide negation
   * or qualification. To make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any implementer is allowed to
   * define an extension, there is a set of requirements that SHALL be met as part of the definition of
   * the extension. Applications processing a resource are required to check for modifier extensions.
   * 
   * Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Extension)
  protected modifierExtension?: Extension[];

  /**
   * String of characters used to identify a name or a resource
   * Field access restricted because there are specific valid values.
   */
  protected url?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _url?: Element;

  /**
   * A sequence of Unicode characters
   * Field access restricted because there are specific valid values.
   */
  protected version?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _version?: Element;

  /**
   * A sequence of Unicode characters
   * Field access restricted because there are specific valid values.
   */
  protected name?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _name?: Element;

  /**
   * A URI that is a reference to a canonical URL on a FHIR resource
   * Field access restricted because there are specific valid values.
   */
  protected derivedFrom?: string;

  /**
   * The status of this search parameter. Enables tracking the life-cycle of the content.
   * Field access restricted because there are specific valid values.
   */
  protected status?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _status?: Element;

  /**
   * Value of "true" or "false"
   */
   experimental?: boolean;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _experimental?: Element;

  /**
   * A date, date-time or partial date (e.g. just year or year + month).  If hours and minutes are
   * specified, a time zone SHALL be populated. The format is a union of the schema types gYear,
   * gYearMonth, date and dateTime. Seconds must be provided due to schema type constraints but may be
   * zero-filled and may be ignored.                 Dates SHALL be valid dates.
   * Field access restricted because there are specific valid values.
   */
  protected date?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _date?: Element;

  /**
   * A sequence of Unicode characters
   * Field access restricted because there are specific valid values.
   */
  protected publisher?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _publisher?: Element;

  /**
   * Contact details to assist a user in finding and communicating with the publisher.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => ContactDetail)
  protected contact?: ContactDetail[];

  /**
   * A string that may contain Github Flavored Markdown syntax for optional processing by a mark down
   * presentation engine
   * Field access restricted because there are specific valid values.
   */
  protected description?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _description?: Element;

  /**
   * The content was developed with a focus and intent of supporting the contexts that are listed. These
   * contexts may be general categories (gender, age, ...) or may be references to specific programs
   * (insurance plans, studies, ...) and may be used to assist with indexing and searching for
   * appropriate search parameter instances.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => UsageContext)
  protected useContext?: UsageContext[];

  /**
   * A legal or geographic region in which the search parameter is intended to be used.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => CodeableConcept)
  protected jurisdiction?: CodeableConcept[];

  /**
   * A string that may contain Github Flavored Markdown syntax for optional processing by a mark down
   * presentation engine
   * Field access restricted because there are specific valid values.
   */
  protected purpose?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _purpose?: Element;

  /**
   * A string which has at least one character and no leading or trailing whitespace and where there is
   * no whitespace other than single spaces in the contents
   * Field access restricted because there are specific valid values.
   */
  protected code?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _code?: Element;

  /**
   * The base resource type(s) that this search parameter can be used against.
   * Field access restricted because there are specific valid values.
   */
  protected base?: string[];

  /**
   * Extensions for base
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Element)
  protected _base?: Element[];

  /**
   * The type of value that a search parameter may contain, and how the content is interpreted.
   * Field access restricted because there are specific valid values.
   */
  protected type?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _type?: Element;

  /**
   * A sequence of Unicode characters
   * Field access restricted because there are specific valid values.
   */
  protected expression?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _expression?: Element;

  /**
   * A sequence of Unicode characters
   * Field access restricted because there are specific valid values.
   */
  protected xpath?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _xpath?: Element;

  /**
   * How the search parameter relates to the set of elements returned by evaluating the xpath query.
   * Field access restricted because there are specific valid values.
   */
  protected xpathUsage?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _xpathUsage?: Element;

  /**
   * Types of resource (if a resource is referenced).
   * Field access restricted because there are specific valid values.
   */
  protected target?: string[];

  /**
   * Extensions for target
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Element)
  protected _target?: Element[];

  /**
   * Value of "true" or "false"
   */
   multipleOr?: boolean;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _multipleOr?: Element;

  /**
   * Value of "true" or "false"
   */
   multipleAnd?: boolean;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _multipleAnd?: Element;

  /**
   * Comparators supported for the search parameter.
   * Field access restricted because there are specific valid values.
   */
  protected comparator?: string[];

  /**
   * Extensions for comparator
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Element)
  protected _comparator?: Element[];

  /**
   * A modifier supported for the search parameter.
   * Field access restricted because there are specific valid values.
   */
  protected modifier?: string[];

  /**
   * Extensions for modifier
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Element)
  protected _modifier?: Element[];

  /**
   * Contains the names of any search parameters which may be chained to the containing search
   * parameter. Chained parameters may be added to search parameters of type reference and specify that
   * resources will only be returned if they contain a reference to a resource which matches the chained
   * parameter value. Values for this field should be drawn from SearchParameter.code for a parameter on
   * the target resource type.
   * Field access restricted because there are specific valid values.
   */
  protected chain?: string[];

  /**
   * Extensions for chain
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Element)
  protected _chain?: Element[];

  /**
   * Used to define the parts of a composite search parameter.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => SearchParameterComponent)
  protected component?: SearchParameterComponent[];


  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setId(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.id) !== 'undefined') {
         delete this.id;
      }
      return;
    }
    
    if (REGEX_ID_000.test(newValue)) {
      this.id = newValue
    } else {
      throw new Error("Invalid value pattern for id of " + newValue);
    }
  }
  
  public getIdPattern(): string {
    return REGEX_ID_000.source;
  }
  
  /**
  * Gets the current value of field id.
  * @returns the value  or undefined
  */
  public getId(): string | undefined {
      return this.id;
  }

  /**
  * Gets the current value of field id if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getIdOrElse(defaultValue: string): string {
      if (this.id == undefined || this.id == null ) { return defaultValue; }
      return this.id;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setImplicitRules(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.implicitRules) !== 'undefined') {
         delete this.implicitRules;
      }
      return;
    }
    
    if (REGEX_IMPLICITRULES.test(newValue)) {
      this.implicitRules = newValue
    } else {
      throw new Error("Invalid value pattern for implicitRules of " + newValue);
    }
  }
  
  public getImplicitRulesPattern(): string {
    return REGEX_IMPLICITRULES.source;
  }
  
  /**
  * Gets the current value of field implicitRules.
  * @returns the value  or undefined
  */
  public getImplicitRules(): string | undefined {
      return this.implicitRules;
  }

  /**
  * Gets the current value of field implicitRules if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getImplicitRulesOrElse(defaultValue: string): string {
      if (this.implicitRules == undefined || this.implicitRules == null ) { return defaultValue; }
      return this.implicitRules;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setLanguage(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.language) !== 'undefined') {
         delete this.language;
      }
      return;
    }
    
    if (REGEX_LANGUAGE.test(newValue)) {
      this.language = newValue
    } else {
      throw new Error("Invalid value pattern for language of " + newValue);
    }
  }
  
  public getLanguagePattern(): string {
    return REGEX_LANGUAGE.source;
  }
  
  /**
  * Gets the current value of field language.
  * @returns the value  or undefined
  */
  public getLanguage(): string | undefined {
      return this.language;
  }

  /**
  * Gets the current value of field language if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getLanguageOrElse(defaultValue: string): string {
      if (this.language == undefined || this.language == null ) { return defaultValue; }
      return this.language;
  }

  public addContained(newValue: ResourceList) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.contained) !== 'undefined') {
         delete this.contained;
      }
      return;
    }
    
    if (typeof(this.contained) === 'undefined') {
      this.contained =  [];
    }
    this.contained.push(newValue);
  }
  /**
  * Removes all elements from the array contained, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteContainedAll(): ResourceList[] {
    if (typeof(this.contained) !== 'undefined') {
       const oldArray = this.contained;
       delete this.contained;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array contained, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteContainedBySplice(start: number, deleteCount?: number): ResourceList[] {
    if (typeof(this.contained) !== 'undefined') {
       return this.contained.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field contained.
  * @returns the value  or undefined
  */
  public getContained(): ResourceList[] | undefined {
      return this.contained;
  }

  /**
  * Gets the current value of field contained if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getContainedOrElse(defaultValue: ResourceList[]): ResourceList[] {
      if (this.contained == undefined || this.contained == null ) { return defaultValue; }
      return this.contained;
  }

  public addExtension(newValue: Extension) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.extension) !== 'undefined') {
         delete this.extension;
      }
      return;
    }
    
    if (typeof(this.extension) === 'undefined') {
      this.extension =  [];
    }
    this.extension.push(newValue);
  }
  /**
  * Removes all elements from the array extension, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteExtensionAll(): Extension[] {
    if (typeof(this.extension) !== 'undefined') {
       const oldArray = this.extension;
       delete this.extension;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array extension, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteExtensionBySplice(start: number, deleteCount?: number): Extension[] {
    if (typeof(this.extension) !== 'undefined') {
       return this.extension.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field extension.
  * @returns the value  or undefined
  */
  public getExtension(): Extension[] | undefined {
      return this.extension;
  }

  /**
  * Gets the current value of field extension if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getExtensionOrElse(defaultValue: Extension[]): Extension[] {
      if (this.extension == undefined || this.extension == null ) { return defaultValue; }
      return this.extension;
  }

  public addModifierExtension(newValue: Extension) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.modifierExtension) !== 'undefined') {
         delete this.modifierExtension;
      }
      return;
    }
    
    if (typeof(this.modifierExtension) === 'undefined') {
      this.modifierExtension =  [];
    }
    this.modifierExtension.push(newValue);
  }
  /**
  * Removes all elements from the array modifierExtension, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteModifierExtensionAll(): Extension[] {
    if (typeof(this.modifierExtension) !== 'undefined') {
       const oldArray = this.modifierExtension;
       delete this.modifierExtension;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array modifierExtension, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteModifierExtensionBySplice(start: number, deleteCount?: number): Extension[] {
    if (typeof(this.modifierExtension) !== 'undefined') {
       return this.modifierExtension.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field modifierExtension.
  * @returns the value  or undefined
  */
  public getModifierExtension(): Extension[] | undefined {
      return this.modifierExtension;
  }

  /**
  * Gets the current value of field modifierExtension if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getModifierExtensionOrElse(defaultValue: Extension[]): Extension[] {
      if (this.modifierExtension == undefined || this.modifierExtension == null ) { return defaultValue; }
      return this.modifierExtension;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setUrl(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.url) !== 'undefined') {
         delete this.url;
      }
      return;
    }
    
    if (REGEX_URL.test(newValue)) {
      this.url = newValue
    } else {
      throw new Error("Invalid value pattern for url of " + newValue);
    }
  }
  
  public getUrlPattern(): string {
    return REGEX_URL.source;
  }
  
  /**
  * Gets the current value of field url.
  * @returns the value  or undefined
  */
  public getUrl(): string | undefined {
      return this.url;
  }

  /**
  * Gets the current value of field url if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getUrlOrElse(defaultValue: string): string {
      if (this.url == undefined || this.url == null ) { return defaultValue; }
      return this.url;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setVersion(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.version) !== 'undefined') {
         delete this.version;
      }
      return;
    }
    
    if (REGEX_VERSION.test(newValue)) {
      this.version = newValue
    } else {
      throw new Error("Invalid value pattern for version of " + newValue);
    }
  }
  
  public getVersionPattern(): string {
    return REGEX_VERSION.source;
  }
  
  /**
  * Gets the current value of field version.
  * @returns the value  or undefined
  */
  public getVersion(): string | undefined {
      return this.version;
  }

  /**
  * Gets the current value of field version if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getVersionOrElse(defaultValue: string): string {
      if (this.version == undefined || this.version == null ) { return defaultValue; }
      return this.version;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setName(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.name) !== 'undefined') {
         delete this.name;
      }
      return;
    }
    
    if (REGEX_NAME.test(newValue)) {
      this.name = newValue
    } else {
      throw new Error("Invalid value pattern for name of " + newValue);
    }
  }
  
  public getNamePattern(): string {
    return REGEX_NAME.source;
  }
  
  /**
  * Gets the current value of field name.
  * @returns the value  or undefined
  */
  public getName(): string | undefined {
      return this.name;
  }

  /**
  * Gets the current value of field name if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getNameOrElse(defaultValue: string): string {
      if (this.name == undefined || this.name == null ) { return defaultValue; }
      return this.name;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setDerivedFrom(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.derivedFrom) !== 'undefined') {
         delete this.derivedFrom;
      }
      return;
    }
    
    if (REGEX_DERIVEDFROM.test(newValue)) {
      this.derivedFrom = newValue
    } else {
      throw new Error("Invalid value pattern for derivedFrom of " + newValue);
    }
  }
  
  public getDerivedFromPattern(): string {
    return REGEX_DERIVEDFROM.source;
  }
  
  /**
  * Gets the current value of field derivedFrom.
  * @returns the value  or undefined
  */
  public getDerivedFrom(): string | undefined {
      return this.derivedFrom;
  }

  /**
  * Gets the current value of field derivedFrom if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getDerivedFromOrElse(defaultValue: string): string {
      if (this.derivedFrom == undefined || this.derivedFrom == null ) { return defaultValue; }
      return this.derivedFrom;
  }

  /*
  * This sets the data ensuring that the value is valid.  If not valid, it throws an error
  * that should be caught.
  */
  public setStatus(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.status) !== 'undefined') {
         delete this.status;
      }
      return;
    }
    
    const idx = getValidValueIdx(SearchParameterStatus_list_ValidValues, newValue);
    if (idx >= 0) {
      this.status = SearchParameterStatus_list_ValidValues[idx];
    } else {
      throw new Error("Unknown status of " + newValue);
    }
  }
  
  public getSearchParameterStatusValidValues(): string[] {
    return SearchParameterStatus_list_ValidValues;
  }
  
  /**
  * Gets the current value of field status.
  * @returns the value  or undefined
  */
  public getStatus(): string | undefined {
      return this.status;
  }

  /**
  * Gets the current value of field status if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getStatusOrElse(defaultValue: string): string {
      if (this.status == undefined || this.status == null ) { return defaultValue; }
      return this.status;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setDate(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.date) !== 'undefined') {
         delete this.date;
      }
      return;
    }
    
    if (REGEX_DATE.test(newValue)) {
      this.date = newValue
    } else {
      throw new Error("Invalid value pattern for date of " + newValue);
    }
  }
  
  public getDatePattern(): string {
    return REGEX_DATE.source;
  }
  
  /**
  * Gets the current value of field date.
  * @returns the value  or undefined
  */
  public getDate(): string | undefined {
      return this.date;
  }

  /**
  * Gets the current value of field date if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getDateOrElse(defaultValue: string): string {
      if (this.date == undefined || this.date == null ) { return defaultValue; }
      return this.date;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setPublisher(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.publisher) !== 'undefined') {
         delete this.publisher;
      }
      return;
    }
    
    if (REGEX_PUBLISHER.test(newValue)) {
      this.publisher = newValue
    } else {
      throw new Error("Invalid value pattern for publisher of " + newValue);
    }
  }
  
  public getPublisherPattern(): string {
    return REGEX_PUBLISHER.source;
  }
  
  /**
  * Gets the current value of field publisher.
  * @returns the value  or undefined
  */
  public getPublisher(): string | undefined {
      return this.publisher;
  }

  /**
  * Gets the current value of field publisher if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getPublisherOrElse(defaultValue: string): string {
      if (this.publisher == undefined || this.publisher == null ) { return defaultValue; }
      return this.publisher;
  }

  public addContact(newValue: ContactDetail) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.contact) !== 'undefined') {
         delete this.contact;
      }
      return;
    }
    
    if (typeof(this.contact) === 'undefined') {
      this.contact =  [];
    }
    this.contact.push(newValue);
  }
  /**
  * Removes all elements from the array contact, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteContactAll(): ContactDetail[] {
    if (typeof(this.contact) !== 'undefined') {
       const oldArray = this.contact;
       delete this.contact;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array contact, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteContactBySplice(start: number, deleteCount?: number): ContactDetail[] {
    if (typeof(this.contact) !== 'undefined') {
       return this.contact.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field contact.
  * @returns the value  or undefined
  */
  public getContact(): ContactDetail[] | undefined {
      return this.contact;
  }

  /**
  * Gets the current value of field contact if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getContactOrElse(defaultValue: ContactDetail[]): ContactDetail[] {
      if (this.contact == undefined || this.contact == null ) { return defaultValue; }
      return this.contact;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setDescription(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.description) !== 'undefined') {
         delete this.description;
      }
      return;
    }
    
    if (REGEX_DESCRIPTION.test(newValue)) {
      this.description = newValue
    } else {
      throw new Error("Invalid value pattern for description of " + newValue);
    }
  }
  
  public getDescriptionPattern(): string {
    return REGEX_DESCRIPTION.source;
  }
  
  /**
  * Gets the current value of field description.
  * @returns the value  or undefined
  */
  public getDescription(): string | undefined {
      return this.description;
  }

  /**
  * Gets the current value of field description if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getDescriptionOrElse(defaultValue: string): string {
      if (this.description == undefined || this.description == null ) { return defaultValue; }
      return this.description;
  }

  public addUseContext(newValue: UsageContext) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.useContext) !== 'undefined') {
         delete this.useContext;
      }
      return;
    }
    
    if (typeof(this.useContext) === 'undefined') {
      this.useContext =  [];
    }
    this.useContext.push(newValue);
  }
  /**
  * Removes all elements from the array useContext, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteUseContextAll(): UsageContext[] {
    if (typeof(this.useContext) !== 'undefined') {
       const oldArray = this.useContext;
       delete this.useContext;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array useContext, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteUseContextBySplice(start: number, deleteCount?: number): UsageContext[] {
    if (typeof(this.useContext) !== 'undefined') {
       return this.useContext.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field useContext.
  * @returns the value  or undefined
  */
  public getUseContext(): UsageContext[] | undefined {
      return this.useContext;
  }

  /**
  * Gets the current value of field useContext if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getUseContextOrElse(defaultValue: UsageContext[]): UsageContext[] {
      if (this.useContext == undefined || this.useContext == null ) { return defaultValue; }
      return this.useContext;
  }

  public addJurisdiction(newValue: CodeableConcept) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.jurisdiction) !== 'undefined') {
         delete this.jurisdiction;
      }
      return;
    }
    
    if (typeof(this.jurisdiction) === 'undefined') {
      this.jurisdiction =  [];
    }
    this.jurisdiction.push(newValue);
  }
  /**
  * Removes all elements from the array jurisdiction, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteJurisdictionAll(): CodeableConcept[] {
    if (typeof(this.jurisdiction) !== 'undefined') {
       const oldArray = this.jurisdiction;
       delete this.jurisdiction;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array jurisdiction, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteJurisdictionBySplice(start: number, deleteCount?: number): CodeableConcept[] {
    if (typeof(this.jurisdiction) !== 'undefined') {
       return this.jurisdiction.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field jurisdiction.
  * @returns the value  or undefined
  */
  public getJurisdiction(): CodeableConcept[] | undefined {
      return this.jurisdiction;
  }

  /**
  * Gets the current value of field jurisdiction if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getJurisdictionOrElse(defaultValue: CodeableConcept[]): CodeableConcept[] {
      if (this.jurisdiction == undefined || this.jurisdiction == null ) { return defaultValue; }
      return this.jurisdiction;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setPurpose(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.purpose) !== 'undefined') {
         delete this.purpose;
      }
      return;
    }
    
    if (REGEX_PURPOSE.test(newValue)) {
      this.purpose = newValue
    } else {
      throw new Error("Invalid value pattern for purpose of " + newValue);
    }
  }
  
  public getPurposePattern(): string {
    return REGEX_PURPOSE.source;
  }
  
  /**
  * Gets the current value of field purpose.
  * @returns the value  or undefined
  */
  public getPurpose(): string | undefined {
      return this.purpose;
  }

  /**
  * Gets the current value of field purpose if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getPurposeOrElse(defaultValue: string): string {
      if (this.purpose == undefined || this.purpose == null ) { return defaultValue; }
      return this.purpose;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setCode(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.code) !== 'undefined') {
         delete this.code;
      }
      return;
    }
    
    if (REGEX_CODE.test(newValue)) {
      this.code = newValue
    } else {
      throw new Error("Invalid value pattern for code of " + newValue);
    }
  }
  
  public getCodePattern(): string {
    return REGEX_CODE.source;
  }
  
  /**
  * Gets the current value of field code.
  * @returns the value  or undefined
  */
  public getCode(): string | undefined {
      return this.code;
  }

  /**
  * Gets the current value of field code if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getCodeOrElse(defaultValue: string): string {
      if (this.code == undefined || this.code == null ) { return defaultValue; }
      return this.code;
  }

  public addBase(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.base) !== 'undefined') {
         delete this.base;
      }
      return;
    }
    
    if (typeof(this.base) === 'undefined') {
      this.base =  [];
    }
    this.base.push(newValue);
  }
  /**
  * Removes all elements from the array base, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteBaseAll(): string[] {
    if (typeof(this.base) !== 'undefined') {
       const oldArray = this.base;
       delete this.base;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array base, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteBaseBySplice(start: number, deleteCount?: number): string[] {
    if (typeof(this.base) !== 'undefined') {
       return this.base.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field base.
  * @returns the value  or undefined
  */
  public getBase(): string[] | undefined {
      return this.base;
  }

  /**
  * Gets the current value of field base if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getBaseOrElse(defaultValue: string[]): string[] {
      if (this.base == undefined || this.base == null ) { return defaultValue; }
      return this.base;
  }

  public add_base(newValue: Element) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this._base) !== 'undefined') {
         delete this._base;
      }
      return;
    }
    
    if (typeof(this._base) === 'undefined') {
      this._base =  [];
    }
    this._base.push(newValue);
  }
  /**
  * Removes all elements from the array _base, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public delete_baseAll(): Element[] {
    if (typeof(this._base) !== 'undefined') {
       const oldArray = this._base;
       delete this._base;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array _base, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public delete_baseBySplice(start: number, deleteCount?: number): Element[] {
    if (typeof(this._base) !== 'undefined') {
       return this._base.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field _base.
  * @returns the value  or undefined
  */
  public get_base(): Element[] | undefined {
      return this._base;
  }

  /**
  * Gets the current value of field _base if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public get_baseOrElse(defaultValue: Element[]): Element[] {
      if (this._base == undefined || this._base == null ) { return defaultValue; }
      return this._base;
  }

  /*
  * This sets the data ensuring that the value is valid.  If not valid, it throws an error
  * that should be caught.
  */
  public setType(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.type) !== 'undefined') {
         delete this.type;
      }
      return;
    }
    
    const idx = getValidValueIdx(SearchParameterType_list_ValidValues, newValue);
    if (idx >= 0) {
      this.type = SearchParameterType_list_ValidValues[idx];
    } else {
      throw new Error("Unknown type of " + newValue);
    }
  }
  
  public getSearchParameterTypeValidValues(): string[] {
    return SearchParameterType_list_ValidValues;
  }
  
  /**
  * Gets the current value of field type.
  * @returns the value  or undefined
  */
  public getType(): string | undefined {
      return this.type;
  }

  /**
  * Gets the current value of field type if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getTypeOrElse(defaultValue: string): string {
      if (this.type == undefined || this.type == null ) { return defaultValue; }
      return this.type;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setExpression(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.expression) !== 'undefined') {
         delete this.expression;
      }
      return;
    }
    
    if (REGEX_EXPRESSION.test(newValue)) {
      this.expression = newValue
    } else {
      throw new Error("Invalid value pattern for expression of " + newValue);
    }
  }
  
  public getExpressionPattern(): string {
    return REGEX_EXPRESSION.source;
  }
  
  /**
  * Gets the current value of field expression.
  * @returns the value  or undefined
  */
  public getExpression(): string | undefined {
      return this.expression;
  }

  /**
  * Gets the current value of field expression if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getExpressionOrElse(defaultValue: string): string {
      if (this.expression == undefined || this.expression == null ) { return defaultValue; }
      return this.expression;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setXpath(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.xpath) !== 'undefined') {
         delete this.xpath;
      }
      return;
    }
    
    if (REGEX_XPATH.test(newValue)) {
      this.xpath = newValue
    } else {
      throw new Error("Invalid value pattern for xpath of " + newValue);
    }
  }
  
  public getXpathPattern(): string {
    return REGEX_XPATH.source;
  }
  
  /**
  * Gets the current value of field xpath.
  * @returns the value  or undefined
  */
  public getXpath(): string | undefined {
      return this.xpath;
  }

  /**
  * Gets the current value of field xpath if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getXpathOrElse(defaultValue: string): string {
      if (this.xpath == undefined || this.xpath == null ) { return defaultValue; }
      return this.xpath;
  }

  /*
  * This sets the data ensuring that the value is valid.  If not valid, it throws an error
  * that should be caught.
  */
  public setXpathUsage(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.xpathUsage) !== 'undefined') {
         delete this.xpathUsage;
      }
      return;
    }
    
    const idx = getValidValueIdx(SearchParameterXpathUsage_list_ValidValues, newValue);
    if (idx >= 0) {
      this.xpathUsage = SearchParameterXpathUsage_list_ValidValues[idx];
    } else {
      throw new Error("Unknown xpathUsage of " + newValue);
    }
  }
  
  public getSearchParameterXpathUsageValidValues(): string[] {
    return SearchParameterXpathUsage_list_ValidValues;
  }
  
  /**
  * Gets the current value of field xpathUsage.
  * @returns the value  or undefined
  */
  public getXpathUsage(): string | undefined {
      return this.xpathUsage;
  }

  /**
  * Gets the current value of field xpathUsage if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getXpathUsageOrElse(defaultValue: string): string {
      if (this.xpathUsage == undefined || this.xpathUsage == null ) { return defaultValue; }
      return this.xpathUsage;
  }

  public addTarget(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.target) !== 'undefined') {
         delete this.target;
      }
      return;
    }
    
    if (typeof(this.target) === 'undefined') {
      this.target =  [];
    }
    this.target.push(newValue);
  }
  /**
  * Removes all elements from the array target, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteTargetAll(): string[] {
    if (typeof(this.target) !== 'undefined') {
       const oldArray = this.target;
       delete this.target;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array target, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteTargetBySplice(start: number, deleteCount?: number): string[] {
    if (typeof(this.target) !== 'undefined') {
       return this.target.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field target.
  * @returns the value  or undefined
  */
  public getTarget(): string[] | undefined {
      return this.target;
  }

  /**
  * Gets the current value of field target if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getTargetOrElse(defaultValue: string[]): string[] {
      if (this.target == undefined || this.target == null ) { return defaultValue; }
      return this.target;
  }

  public add_target(newValue: Element) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this._target) !== 'undefined') {
         delete this._target;
      }
      return;
    }
    
    if (typeof(this._target) === 'undefined') {
      this._target =  [];
    }
    this._target.push(newValue);
  }
  /**
  * Removes all elements from the array _target, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public delete_targetAll(): Element[] {
    if (typeof(this._target) !== 'undefined') {
       const oldArray = this._target;
       delete this._target;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array _target, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public delete_targetBySplice(start: number, deleteCount?: number): Element[] {
    if (typeof(this._target) !== 'undefined') {
       return this._target.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field _target.
  * @returns the value  or undefined
  */
  public get_target(): Element[] | undefined {
      return this._target;
  }

  /**
  * Gets the current value of field _target if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public get_targetOrElse(defaultValue: Element[]): Element[] {
      if (this._target == undefined || this._target == null ) { return defaultValue; }
      return this._target;
  }

  public addComparator(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.comparator) !== 'undefined') {
         delete this.comparator;
      }
      return;
    }
    
    if (typeof(this.comparator) === 'undefined') {
      this.comparator =  [];
    }
    this.comparator.push(newValue);
  }
  /**
  * Removes all elements from the array comparator, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteComparatorAll(): string[] {
    if (typeof(this.comparator) !== 'undefined') {
       const oldArray = this.comparator;
       delete this.comparator;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array comparator, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteComparatorBySplice(start: number, deleteCount?: number): string[] {
    if (typeof(this.comparator) !== 'undefined') {
       return this.comparator.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field comparator.
  * @returns the value  or undefined
  */
  public getComparator(): string[] | undefined {
      return this.comparator;
  }

  /**
  * Gets the current value of field comparator if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getComparatorOrElse(defaultValue: string[]): string[] {
      if (this.comparator == undefined || this.comparator == null ) { return defaultValue; }
      return this.comparator;
  }

  public add_comparator(newValue: Element) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this._comparator) !== 'undefined') {
         delete this._comparator;
      }
      return;
    }
    
    if (typeof(this._comparator) === 'undefined') {
      this._comparator =  [];
    }
    this._comparator.push(newValue);
  }
  /**
  * Removes all elements from the array _comparator, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public delete_comparatorAll(): Element[] {
    if (typeof(this._comparator) !== 'undefined') {
       const oldArray = this._comparator;
       delete this._comparator;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array _comparator, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public delete_comparatorBySplice(start: number, deleteCount?: number): Element[] {
    if (typeof(this._comparator) !== 'undefined') {
       return this._comparator.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field _comparator.
  * @returns the value  or undefined
  */
  public get_comparator(): Element[] | undefined {
      return this._comparator;
  }

  /**
  * Gets the current value of field _comparator if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public get_comparatorOrElse(defaultValue: Element[]): Element[] {
      if (this._comparator == undefined || this._comparator == null ) { return defaultValue; }
      return this._comparator;
  }

  public addModifier(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.modifier) !== 'undefined') {
         delete this.modifier;
      }
      return;
    }
    
    if (typeof(this.modifier) === 'undefined') {
      this.modifier =  [];
    }
    this.modifier.push(newValue);
  }
  /**
  * Removes all elements from the array modifier, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteModifierAll(): string[] {
    if (typeof(this.modifier) !== 'undefined') {
       const oldArray = this.modifier;
       delete this.modifier;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array modifier, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteModifierBySplice(start: number, deleteCount?: number): string[] {
    if (typeof(this.modifier) !== 'undefined') {
       return this.modifier.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field modifier.
  * @returns the value  or undefined
  */
  public getModifier(): string[] | undefined {
      return this.modifier;
  }

  /**
  * Gets the current value of field modifier if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getModifierOrElse(defaultValue: string[]): string[] {
      if (this.modifier == undefined || this.modifier == null ) { return defaultValue; }
      return this.modifier;
  }

  public add_modifier(newValue: Element) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this._modifier) !== 'undefined') {
         delete this._modifier;
      }
      return;
    }
    
    if (typeof(this._modifier) === 'undefined') {
      this._modifier =  [];
    }
    this._modifier.push(newValue);
  }
  /**
  * Removes all elements from the array _modifier, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public delete_modifierAll(): Element[] {
    if (typeof(this._modifier) !== 'undefined') {
       const oldArray = this._modifier;
       delete this._modifier;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array _modifier, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public delete_modifierBySplice(start: number, deleteCount?: number): Element[] {
    if (typeof(this._modifier) !== 'undefined') {
       return this._modifier.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field _modifier.
  * @returns the value  or undefined
  */
  public get_modifier(): Element[] | undefined {
      return this._modifier;
  }

  /**
  * Gets the current value of field _modifier if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public get_modifierOrElse(defaultValue: Element[]): Element[] {
      if (this._modifier == undefined || this._modifier == null ) { return defaultValue; }
      return this._modifier;
  }

  public addChain(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.chain) !== 'undefined') {
         delete this.chain;
      }
      return;
    }
    
    if (typeof(this.chain) === 'undefined') {
      this.chain =  [];
    }
    this.chain.push(newValue);
  }
  /**
  * Removes all elements from the array chain, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteChainAll(): string[] {
    if (typeof(this.chain) !== 'undefined') {
       const oldArray = this.chain;
       delete this.chain;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array chain, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteChainBySplice(start: number, deleteCount?: number): string[] {
    if (typeof(this.chain) !== 'undefined') {
       return this.chain.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field chain.
  * @returns the value  or undefined
  */
  public getChain(): string[] | undefined {
      return this.chain;
  }

  /**
  * Gets the current value of field chain if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getChainOrElse(defaultValue: string[]): string[] {
      if (this.chain == undefined || this.chain == null ) { return defaultValue; }
      return this.chain;
  }

  public add_chain(newValue: Element) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this._chain) !== 'undefined') {
         delete this._chain;
      }
      return;
    }
    
    if (typeof(this._chain) === 'undefined') {
      this._chain =  [];
    }
    this._chain.push(newValue);
  }
  /**
  * Removes all elements from the array _chain, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public delete_chainAll(): Element[] {
    if (typeof(this._chain) !== 'undefined') {
       const oldArray = this._chain;
       delete this._chain;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array _chain, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public delete_chainBySplice(start: number, deleteCount?: number): Element[] {
    if (typeof(this._chain) !== 'undefined') {
       return this._chain.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field _chain.
  * @returns the value  or undefined
  */
  public get_chain(): Element[] | undefined {
      return this._chain;
  }

  /**
  * Gets the current value of field _chain if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public get_chainOrElse(defaultValue: Element[]): Element[] {
      if (this._chain == undefined || this._chain == null ) { return defaultValue; }
      return this._chain;
  }

  public addComponent(newValue: SearchParameterComponent) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.component) !== 'undefined') {
         delete this.component;
      }
      return;
    }
    
    if (typeof(this.component) === 'undefined') {
      this.component =  [];
    }
    this.component.push(newValue);
  }
  /**
  * Removes all elements from the array component, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteComponentAll(): SearchParameterComponent[] {
    if (typeof(this.component) !== 'undefined') {
       const oldArray = this.component;
       delete this.component;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array component, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteComponentBySplice(start: number, deleteCount?: number): SearchParameterComponent[] {
    if (typeof(this.component) !== 'undefined') {
       return this.component.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field component.
  * @returns the value  or undefined
  */
  public getComponent(): SearchParameterComponent[] | undefined {
      return this.component;
  }

  /**
  * Gets the current value of field component if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getComponentOrElse(defaultValue: SearchParameterComponent[]): SearchParameterComponent[] {
      if (this.component == undefined || this.component == null ) { return defaultValue; }
      return this.component;
  }


}


