import { Type } from 'class-transformer';
import { REGEX_ID, REGEX_PREFIX, REGEX_TITLE, REGEX_DESCRIPTION, REGEX_TEXTEQUIVALENT, REGEX_PRIORITY, REGEX_TIMINGDATETIME, REGEX_GROUPINGBEHAVIOR, REGEX_SELECTIONBEHAVIOR, REGEX_REQUIREDBEHAVIOR, REGEX_PRECHECKBEHAVIOR, REGEX_CARDINALITYBEHAVIOR } from '../FhirTsLibValidation/FhirRegex';
import { Age, CodeableConcept, Duration, Element, Extension, Period, Range, Reference, RelatedArtifact, RequestGroupCondition, RequestGroupRelatedAction, Timing } from './FhirType';



/**
 * A group of related requests that can be used to capture intended activities that have
 * inter-dependencies such as "give this medication after that one".
 *
 * Generated by Gallaware, Inc. from:
 *    file:/Users/admin/Documents/DevNetbeans/jsonSchemaToJava/target/classes/schema/fhir.schema.json#/definitions/RequestGroup_Action
 */
export class RequestGroupAction {
  /**
   * A sequence of Unicode characters
   * Field access restricted because there are specific valid values.
   */
  protected id?: string;

  /**
   * May be used to represent additional information that is not part of the basic definition of the
   * element. To make the use of extensions safe and manageable, there is a strict set of governance
   * applied to the definition and use of extensions. Though any implementer can define an extension,
   * there is a set of requirements that SHALL be met as part of the definition of the extension.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Extension)
  protected extension?: Extension[];

  /**
   * May be used to represent additional information that is not part of the basic definition of the
   * element and that modifies the understanding of the element in which it is contained and/or the
   * understanding of the containing element's descendants. Usually modifier elements provide negation
   * or qualification. To make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any implementer can define an
   * extension, there is a set of requirements that SHALL be met as part of the definition of the
   * extension. Applications processing a resource are required to check for modifier extensions.
   * 
   * Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Extension)
  protected modifierExtension?: Extension[];

  /**
   * A sequence of Unicode characters
   * Field access restricted because there are specific valid values.
   */
  protected prefix?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _prefix?: Element;

  /**
   * A sequence of Unicode characters
   * Field access restricted because there are specific valid values.
   */
  protected title?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _title?: Element;

  /**
   * A sequence of Unicode characters
   * Field access restricted because there are specific valid values.
   */
  protected description?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _description?: Element;

  /**
   * A sequence of Unicode characters
   * Field access restricted because there are specific valid values.
   */
  protected textEquivalent?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _textEquivalent?: Element;

  /**
   * A string which has at least one character and no leading or trailing whitespace and where there is
   * no whitespace other than single spaces in the contents
   * Field access restricted because there are specific valid values.
   */
  protected priority?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _priority?: Element;

  /**
   * A code that provides meaning for the action or action group. For example, a section may have a
   * LOINC code for a section of a documentation template.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => CodeableConcept)
  protected code?: CodeableConcept[];

  /**
   * Didactic or other informational resources associated with the action that can be provided to the
   * CDS recipient. Information resources can include inline text commentary and links to web resources.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => RelatedArtifact)
  protected documentation?: RelatedArtifact[];

  /**
   * An expression that describes applicability criteria, or start/stop conditions for the action.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => RequestGroupCondition)
  protected condition?: RequestGroupCondition[];

  /**
   * A relationship to another action such as "before" or "30-60 minutes after start of".
   * Field access restricted because there are specific valid values.
   */
  @Type(() => RequestGroupRelatedAction)
  protected relatedAction?: RequestGroupRelatedAction[];

  /**
   * An optional value describing when the action should be performed.
   * Field access restricted because there are specific valid values.
   */
  protected timingDateTime?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _timingDateTime?: Element;

  /**
   * A duration of time during which an organism (or a process) has existed.
   */
  @Type(() => Age)
   timingAge?: Age;

  /**
   * A time period defined by a start and end date and optionally time.
   */
  @Type(() => Period)
   timingPeriod?: Period;

  /**
   * A length of time.
   */
  @Type(() => Duration)
   timingDuration?: Duration;

  /**
   * A set of ordered Quantities defined by a low and high limit.
   */
  @Type(() => Range)
   timingRange?: Range;

  /**
   * Specifies an event that may occur multiple times. Timing schedules are used to record when things
   * are planned, expected or requested to occur. The most common usage is in dosage instructions for
   * medications. They are also used when planning care of various kinds, and may be used for reporting
   * the schedule to which past regular activities were carried out.
   */
  @Type(() => Timing)
   timingTiming?: Timing;

  /**
   * The participant that should perform or be responsible for this action.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Reference)
  protected participant?: Reference[];

  /**
   * A concept that may be defined by a formal reference to a terminology or ontology or may be provided
   * by text.
   */
  @Type(() => CodeableConcept)
   type?: CodeableConcept;

  /**
   * A string which has at least one character and no leading or trailing whitespace and where there is
   * no whitespace other than single spaces in the contents
   * Field access restricted because there are specific valid values.
   */
  protected groupingBehavior?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _groupingBehavior?: Element;

  /**
   * A string which has at least one character and no leading or trailing whitespace and where there is
   * no whitespace other than single spaces in the contents
   * Field access restricted because there are specific valid values.
   */
  protected selectionBehavior?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _selectionBehavior?: Element;

  /**
   * A string which has at least one character and no leading or trailing whitespace and where there is
   * no whitespace other than single spaces in the contents
   * Field access restricted because there are specific valid values.
   */
  protected requiredBehavior?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _requiredBehavior?: Element;

  /**
   * A string which has at least one character and no leading or trailing whitespace and where there is
   * no whitespace other than single spaces in the contents
   * Field access restricted because there are specific valid values.
   */
  protected precheckBehavior?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _precheckBehavior?: Element;

  /**
   * A string which has at least one character and no leading or trailing whitespace and where there is
   * no whitespace other than single spaces in the contents
   * Field access restricted because there are specific valid values.
   */
  protected cardinalityBehavior?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _cardinalityBehavior?: Element;

  /**
   * A reference from one resource to another.
   */
  @Type(() => Reference)
   resource?: Reference;

  /**
   * Sub actions.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => RequestGroupAction)
  protected action?: RequestGroupAction[];


  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setId(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.id) !== 'undefined') {
         delete this.id;
      }
      return;
    }
    
    if (REGEX_ID.test(newValue)) {
      this.id = newValue
    } else {
      throw new Error("Invalid value pattern for id of " + newValue);
    }
  }
  
  public getIdPattern(): string {
    return REGEX_ID.source;
  }
  

  public getId(): string | undefined {
      return this.id;
  }

  public addExtension(newValue: Extension) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.extension) !== 'undefined') {
         delete this.extension;
      }
      return;
    }
    
    if (typeof(this.extension) === 'undefined') {
      this.extension =  [];
    }
    this.extension.push(newValue);
  }

  public getExtension(): Extension[] | undefined {
      return this.extension;
  }

  public addModifierExtension(newValue: Extension) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.modifierExtension) !== 'undefined') {
         delete this.modifierExtension;
      }
      return;
    }
    
    if (typeof(this.modifierExtension) === 'undefined') {
      this.modifierExtension =  [];
    }
    this.modifierExtension.push(newValue);
  }

  public getModifierExtension(): Extension[] | undefined {
      return this.modifierExtension;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setPrefix(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.prefix) !== 'undefined') {
         delete this.prefix;
      }
      return;
    }
    
    if (REGEX_PREFIX.test(newValue)) {
      this.prefix = newValue
    } else {
      throw new Error("Invalid value pattern for prefix of " + newValue);
    }
  }
  
  public getPrefixPattern(): string {
    return REGEX_PREFIX.source;
  }
  

  public getPrefix(): string | undefined {
      return this.prefix;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setTitle(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.title) !== 'undefined') {
         delete this.title;
      }
      return;
    }
    
    if (REGEX_TITLE.test(newValue)) {
      this.title = newValue
    } else {
      throw new Error("Invalid value pattern for title of " + newValue);
    }
  }
  
  public getTitlePattern(): string {
    return REGEX_TITLE.source;
  }
  

  public getTitle(): string | undefined {
      return this.title;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setDescription(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.description) !== 'undefined') {
         delete this.description;
      }
      return;
    }
    
    if (REGEX_DESCRIPTION.test(newValue)) {
      this.description = newValue
    } else {
      throw new Error("Invalid value pattern for description of " + newValue);
    }
  }
  
  public getDescriptionPattern(): string {
    return REGEX_DESCRIPTION.source;
  }
  

  public getDescription(): string | undefined {
      return this.description;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setTextEquivalent(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.textEquivalent) !== 'undefined') {
         delete this.textEquivalent;
      }
      return;
    }
    
    if (REGEX_TEXTEQUIVALENT.test(newValue)) {
      this.textEquivalent = newValue
    } else {
      throw new Error("Invalid value pattern for textEquivalent of " + newValue);
    }
  }
  
  public getTextEquivalentPattern(): string {
    return REGEX_TEXTEQUIVALENT.source;
  }
  

  public getTextEquivalent(): string | undefined {
      return this.textEquivalent;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setPriority(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.priority) !== 'undefined') {
         delete this.priority;
      }
      return;
    }
    
    if (REGEX_PRIORITY.test(newValue)) {
      this.priority = newValue
    } else {
      throw new Error("Invalid value pattern for priority of " + newValue);
    }
  }
  
  public getPriorityPattern(): string {
    return REGEX_PRIORITY.source;
  }
  

  public getPriority(): string | undefined {
      return this.priority;
  }

  public addCode(newValue: CodeableConcept) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.code) !== 'undefined') {
         delete this.code;
      }
      return;
    }
    
    if (typeof(this.code) === 'undefined') {
      this.code =  [];
    }
    this.code.push(newValue);
  }

  public getCode(): CodeableConcept[] | undefined {
      return this.code;
  }

  public addDocumentation(newValue: RelatedArtifact) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.documentation) !== 'undefined') {
         delete this.documentation;
      }
      return;
    }
    
    if (typeof(this.documentation) === 'undefined') {
      this.documentation =  [];
    }
    this.documentation.push(newValue);
  }

  public getDocumentation(): RelatedArtifact[] | undefined {
      return this.documentation;
  }

  public addCondition(newValue: RequestGroupCondition) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.condition) !== 'undefined') {
         delete this.condition;
      }
      return;
    }
    
    if (typeof(this.condition) === 'undefined') {
      this.condition =  [];
    }
    this.condition.push(newValue);
  }

  public getCondition(): RequestGroupCondition[] | undefined {
      return this.condition;
  }

  public addRelatedAction(newValue: RequestGroupRelatedAction) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.relatedAction) !== 'undefined') {
         delete this.relatedAction;
      }
      return;
    }
    
    if (typeof(this.relatedAction) === 'undefined') {
      this.relatedAction =  [];
    }
    this.relatedAction.push(newValue);
  }

  public getRelatedAction(): RequestGroupRelatedAction[] | undefined {
      return this.relatedAction;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setTimingDateTime(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.timingDateTime) !== 'undefined') {
         delete this.timingDateTime;
      }
      return;
    }
    
    if (REGEX_TIMINGDATETIME.test(newValue)) {
      this.timingDateTime = newValue
    } else {
      throw new Error("Invalid value pattern for timingDateTime of " + newValue);
    }
  }
  
  public getTimingDateTimePattern(): string {
    return REGEX_TIMINGDATETIME.source;
  }
  

  public getTimingDateTime(): string | undefined {
      return this.timingDateTime;
  }

  public addParticipant(newValue: Reference) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.participant) !== 'undefined') {
         delete this.participant;
      }
      return;
    }
    
    if (typeof(this.participant) === 'undefined') {
      this.participant =  [];
    }
    this.participant.push(newValue);
  }

  public getParticipant(): Reference[] | undefined {
      return this.participant;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setGroupingBehavior(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.groupingBehavior) !== 'undefined') {
         delete this.groupingBehavior;
      }
      return;
    }
    
    if (REGEX_GROUPINGBEHAVIOR.test(newValue)) {
      this.groupingBehavior = newValue
    } else {
      throw new Error("Invalid value pattern for groupingBehavior of " + newValue);
    }
  }
  
  public getGroupingBehaviorPattern(): string {
    return REGEX_GROUPINGBEHAVIOR.source;
  }
  

  public getGroupingBehavior(): string | undefined {
      return this.groupingBehavior;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setSelectionBehavior(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.selectionBehavior) !== 'undefined') {
         delete this.selectionBehavior;
      }
      return;
    }
    
    if (REGEX_SELECTIONBEHAVIOR.test(newValue)) {
      this.selectionBehavior = newValue
    } else {
      throw new Error("Invalid value pattern for selectionBehavior of " + newValue);
    }
  }
  
  public getSelectionBehaviorPattern(): string {
    return REGEX_SELECTIONBEHAVIOR.source;
  }
  

  public getSelectionBehavior(): string | undefined {
      return this.selectionBehavior;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setRequiredBehavior(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.requiredBehavior) !== 'undefined') {
         delete this.requiredBehavior;
      }
      return;
    }
    
    if (REGEX_REQUIREDBEHAVIOR.test(newValue)) {
      this.requiredBehavior = newValue
    } else {
      throw new Error("Invalid value pattern for requiredBehavior of " + newValue);
    }
  }
  
  public getRequiredBehaviorPattern(): string {
    return REGEX_REQUIREDBEHAVIOR.source;
  }
  

  public getRequiredBehavior(): string | undefined {
      return this.requiredBehavior;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setPrecheckBehavior(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.precheckBehavior) !== 'undefined') {
         delete this.precheckBehavior;
      }
      return;
    }
    
    if (REGEX_PRECHECKBEHAVIOR.test(newValue)) {
      this.precheckBehavior = newValue
    } else {
      throw new Error("Invalid value pattern for precheckBehavior of " + newValue);
    }
  }
  
  public getPrecheckBehaviorPattern(): string {
    return REGEX_PRECHECKBEHAVIOR.source;
  }
  

  public getPrecheckBehavior(): string | undefined {
      return this.precheckBehavior;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setCardinalityBehavior(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.cardinalityBehavior) !== 'undefined') {
         delete this.cardinalityBehavior;
      }
      return;
    }
    
    if (REGEX_CARDINALITYBEHAVIOR.test(newValue)) {
      this.cardinalityBehavior = newValue
    } else {
      throw new Error("Invalid value pattern for cardinalityBehavior of " + newValue);
    }
  }
  
  public getCardinalityBehaviorPattern(): string {
    return REGEX_CARDINALITYBEHAVIOR.source;
  }
  

  public getCardinalityBehavior(): string | undefined {
      return this.cardinalityBehavior;
  }

  public addAction(newValue: RequestGroupAction) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.action) !== 'undefined') {
         delete this.action;
      }
      return;
    }
    
    if (typeof(this.action) === 'undefined') {
      this.action =  [];
    }
    this.action.push(newValue);
  }

  public getAction(): RequestGroupAction[] | undefined {
      return this.action;
  }


}


