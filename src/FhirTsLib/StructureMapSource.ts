import { getValidValueIdx } from '../FhirTsLibValidation/FhirUtils';
import { Type } from 'class-transformer';
import { REGEX_ID, REGEX_CONTEXT, REGEX_MAX, REGEX_TYPE_000, REGEX_DEFAULTVALUEBASE64BINARY, REGEX_DEFAULTVALUECANONICAL, REGEX_DEFAULTVALUECODE, REGEX_DEFAULTVALUEDATE, REGEX_DEFAULTVALUEDATETIME, REGEX_DEFAULTVALUEID, REGEX_DEFAULTVALUEINSTANT, REGEX_DEFAULTVALUEMARKDOWN, REGEX_DEFAULTVALUEOID, REGEX_DEFAULTVALUESTRING, REGEX_DEFAULTVALUETIME, REGEX_DEFAULTVALUEURI, REGEX_DEFAULTVALUEURL, REGEX_DEFAULTVALUEUUID, REGEX_ELEMENT, REGEX_VARIABLE, REGEX_CONDITION, REGEX_CHECK, REGEX_LOGMESSAGE } from '../FhirTsLibValidation/FhirRegex';
import { Address, Age, Annotation, Attachment, CodeableConcept, Coding, ContactDetail, ContactPoint, Contributor, Count, DataRequirement, Distance, Dosage, Duration, Element, Expression, Extension, HumanName, Identifier, Meta, Money, ParameterDefinition, Period, Quantity, Range, Ratio, Reference, RelatedArtifact, SampledData, Signature, Timing, TriggerDefinition, UsageContext } from './FhirType';
import { StructureMapSourceListMode_list_ValidValues } from '../FhirTsLibValidation/Fhir_ValidValues';



/**
 * A Map of relationships between 2 structures that can be used to transform data.
 *
 * Generated by Gallaware, Inc. from:
 *    file:/Users/admin/Documents/DevNetbeans/jsonSchemaToJava/target/classes/schema/fhir.schema.json#/definitions/StructureMap_Source
 */
export class StructureMapSource {
  /**
   * A sequence of Unicode characters
   * Field access restricted because there are specific valid values.
   */
  protected id?: string;

  /**
   * May be used to represent additional information that is not part of the basic definition of the
   * element. To make the use of extensions safe and manageable, there is a strict set of governance
   * applied to the definition and use of extensions. Though any implementer can define an extension,
   * there is a set of requirements that SHALL be met as part of the definition of the extension.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Extension)
  protected extension?: Extension[];

  /**
   * May be used to represent additional information that is not part of the basic definition of the
   * element and that modifies the understanding of the element in which it is contained and/or the
   * understanding of the containing element's descendants. Usually modifier elements provide negation
   * or qualification. To make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any implementer can define an
   * extension, there is a set of requirements that SHALL be met as part of the definition of the
   * extension. Applications processing a resource are required to check for modifier extensions.
   * 
   * Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Extension)
  protected modifierExtension?: Extension[];

  /**
   * Any combination of letters, numerals, "-" and ".", with a length limit of 64 characters.  (This
   * might be an integer, an unprefixed OID, UUID or any other identifier pattern that meets these
   * constraints.)  Ids are case-insensitive.
   * Field access restricted because there are specific valid values.
   */
  protected context?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _context?: Element;

  /**
   * A whole number
   */
   min?: number;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _min?: Element;

  /**
   * A sequence of Unicode characters
   * Field access restricted because there are specific valid values.
   */
  protected max?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _max?: Element;

  /**
   * A sequence of Unicode characters
   * Field access restricted because there are specific valid values.
   */
  protected type?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _type?: Element;

  /**
   * A value to use if there is no existing value in the source object.
   * Field access restricted because there are specific valid values.
   */
  protected defaultValueBase64Binary?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _defaultValueBase64Binary?: Element;

  /**
   * A value to use if there is no existing value in the source object.
   */
   defaultValueBoolean?: boolean;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _defaultValueBoolean?: Element;

  /**
   * A value to use if there is no existing value in the source object.
   * Field access restricted because there are specific valid values.
   */
  protected defaultValueCanonical?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _defaultValueCanonical?: Element;

  /**
   * A value to use if there is no existing value in the source object.
   * Field access restricted because there are specific valid values.
   */
  protected defaultValueCode?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _defaultValueCode?: Element;

  /**
   * A value to use if there is no existing value in the source object.
   * Field access restricted because there are specific valid values.
   */
  protected defaultValueDate?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _defaultValueDate?: Element;

  /**
   * A value to use if there is no existing value in the source object.
   * Field access restricted because there are specific valid values.
   */
  protected defaultValueDateTime?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _defaultValueDateTime?: Element;

  /**
   * A value to use if there is no existing value in the source object.
   */
   defaultValueDecimal?: number;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _defaultValueDecimal?: Element;

  /**
   * A value to use if there is no existing value in the source object.
   * Field access restricted because there are specific valid values.
   */
  protected defaultValueId?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _defaultValueId?: Element;

  /**
   * A value to use if there is no existing value in the source object.
   * Field access restricted because there are specific valid values.
   */
  protected defaultValueInstant?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _defaultValueInstant?: Element;

  /**
   * A value to use if there is no existing value in the source object.
   */
   defaultValueInteger?: number;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _defaultValueInteger?: Element;

  /**
   * A value to use if there is no existing value in the source object.
   * Field access restricted because there are specific valid values.
   */
  protected defaultValueMarkdown?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _defaultValueMarkdown?: Element;

  /**
   * A value to use if there is no existing value in the source object.
   * Field access restricted because there are specific valid values.
   */
  protected defaultValueOid?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _defaultValueOid?: Element;

  /**
   * A value to use if there is no existing value in the source object.
   */
   defaultValuePositiveInt?: number;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _defaultValuePositiveInt?: Element;

  /**
   * A value to use if there is no existing value in the source object.
   * Field access restricted because there are specific valid values.
   */
  protected defaultValueString?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _defaultValueString?: Element;

  /**
   * A value to use if there is no existing value in the source object.
   * Field access restricted because there are specific valid values.
   */
  protected defaultValueTime?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _defaultValueTime?: Element;

  /**
   * A value to use if there is no existing value in the source object.
   */
   defaultValueUnsignedInt?: number;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _defaultValueUnsignedInt?: Element;

  /**
   * A value to use if there is no existing value in the source object.
   * Field access restricted because there are specific valid values.
   */
  protected defaultValueUri?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _defaultValueUri?: Element;

  /**
   * A value to use if there is no existing value in the source object.
   * Field access restricted because there are specific valid values.
   */
  protected defaultValueUrl?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _defaultValueUrl?: Element;

  /**
   * A value to use if there is no existing value in the source object.
   * Field access restricted because there are specific valid values.
   */
  protected defaultValueUuid?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _defaultValueUuid?: Element;

  /**
   * An address expressed using postal conventions (as opposed to GPS or other location definition
   * formats).  This data type may be used to convey addresses for use in delivering mail as well as
   * for visiting locations which might not be valid for mail delivery.  There are a variety of postal
   * address formats defined around the world.
   */
  @Type(() => Address)
   defaultValueAddress?: Address;

  /**
   * A duration of time during which an organism (or a process) has existed.
   */
  @Type(() => Age)
   defaultValueAge?: Age;

  /**
   * A  text note which also  contains information about who made the statement and when.
   */
  @Type(() => Annotation)
   defaultValueAnnotation?: Annotation;

  /**
   * For referring to data content defined in other formats.
   */
  @Type(() => Attachment)
   defaultValueAttachment?: Attachment;

  /**
   * A concept that may be defined by a formal reference to a terminology or ontology or may be provided
   * by text.
   */
  @Type(() => CodeableConcept)
   defaultValueCodeableConcept?: CodeableConcept;

  /**
   * A reference to a code defined by a terminology system.
   */
  @Type(() => Coding)
   defaultValueCoding?: Coding;

  /**
   * Details for all kinds of technology mediated contact points for a person or organization, including
   * telephone, email, etc.
   */
  @Type(() => ContactPoint)
   defaultValueContactPoint?: ContactPoint;

  /**
   * A measured amount (or an amount that can potentially be measured). Note that measured amounts
   * include amounts that are not precisely quantified, including amounts involving arbitrary units and
   * floating currencies.
   */
  @Type(() => Count)
   defaultValueCount?: Count;

  /**
   * A length - a value with a unit that is a physical distance.
   */
  @Type(() => Distance)
   defaultValueDistance?: Distance;

  /**
   * A length of time.
   */
  @Type(() => Duration)
   defaultValueDuration?: Duration;

  /**
   * A human's name with the ability to identify parts and usage.
   */
  @Type(() => HumanName)
   defaultValueHumanName?: HumanName;

  /**
   * An identifier - identifies some entity uniquely and unambiguously. Typically this is used for
   * business identifiers.
   */
  @Type(() => Identifier)
   defaultValueIdentifier?: Identifier;

  /**
   * An amount of economic utility in some recognized currency.
   */
  @Type(() => Money)
   defaultValueMoney?: Money;

  /**
   * A time period defined by a start and end date and optionally time.
   */
  @Type(() => Period)
   defaultValuePeriod?: Period;

  /**
   * A measured amount (or an amount that can potentially be measured). Note that measured amounts
   * include amounts that are not precisely quantified, including amounts involving arbitrary units and
   * floating currencies.
   */
  @Type(() => Quantity)
   defaultValueQuantity?: Quantity;

  /**
   * A set of ordered Quantities defined by a low and high limit.
   */
  @Type(() => Range)
   defaultValueRange?: Range;

  /**
   * A relationship of two Quantity values - expressed as a numerator and a denominator.
   */
  @Type(() => Ratio)
   defaultValueRatio?: Ratio;

  /**
   * A reference from one resource to another.
   */
  @Type(() => Reference)
   defaultValueReference?: Reference;

  /**
   * A series of measurements taken by a device, with upper and lower limits. There may be more than one
   * dimension in the data.
   */
  @Type(() => SampledData)
   defaultValueSampledData?: SampledData;

  /**
   * A signature along with supporting context. The signature may be a digital signature that is
   * cryptographic in nature, or some other signature acceptable to the domain. This other signature
   * may be as simple as a graphical image representing a hand-written signature, or a signature
   * ceremony Different signature approaches have different utilities.
   */
  @Type(() => Signature)
   defaultValueSignature?: Signature;

  /**
   * Specifies an event that may occur multiple times. Timing schedules are used to record when things
   * are planned, expected or requested to occur. The most common usage is in dosage instructions for
   * medications. They are also used when planning care of various kinds, and may be used for reporting
   * the schedule to which past regular activities were carried out.
   */
  @Type(() => Timing)
   defaultValueTiming?: Timing;

  /**
   * Specifies contact information for a person or organization.
   */
  @Type(() => ContactDetail)
   defaultValueContactDetail?: ContactDetail;

  /**
   * A contributor to the content of a knowledge asset, including authors, editors, reviewers, and
   * endorsers.
   */
  @Type(() => Contributor)
   defaultValueContributor?: Contributor;

  /**
   * Describes a required data item for evaluation in terms of the type of data, and optional code or
   * date-based filters of the data.
   */
  @Type(() => DataRequirement)
   defaultValueDataRequirement?: DataRequirement;

  /**
   * A expression that is evaluated in a specified context and returns a value. The context of use of
   * the expression must specify the context in which the expression is evaluated, and how the result
   * of the expression is used.
   */
  @Type(() => Expression)
   defaultValueExpression?: Expression;

  /**
   * The parameters to the module. This collection specifies both the input and output parameters. Input
   * parameters are provided by the caller as part of the $evaluate operation. Output parameters are
   * included in the GuidanceResponse.
   */
  @Type(() => ParameterDefinition)
   defaultValueParameterDefinition?: ParameterDefinition;

  /**
   * Related artifacts such as additional documentation, justification, or bibliographic references.
   */
  @Type(() => RelatedArtifact)
   defaultValueRelatedArtifact?: RelatedArtifact;

  /**
   * A description of a triggering event. Triggering events can be named events, data events, or
   * periodic, as determined by the type element.
   */
  @Type(() => TriggerDefinition)
   defaultValueTriggerDefinition?: TriggerDefinition;

  /**
   * Specifies clinical/business/etc. metadata that can be used to retrieve, index and/or categorize an
   * artifact. This metadata can either be specific to the applicable population (e.g., age category,
   * DRG) or the specific context of care (e.g., venue, care setting, provider of care).
   */
  @Type(() => UsageContext)
   defaultValueUsageContext?: UsageContext;

  /**
   * Indicates how the medication is/was taken or should be taken by the patient.
   */
  @Type(() => Dosage)
   defaultValueDosage?: Dosage;

  /**
   * The metadata about a resource. This is content in the resource that is maintained by the
   * infrastructure. Changes to the content might not always be associated with version changes to the
   * resource.
   */
  @Type(() => Meta)
   defaultValueMeta?: Meta;

  /**
   * A sequence of Unicode characters
   * Field access restricted because there are specific valid values.
   */
  protected element?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _element?: Element;

  /**
   * How to handle the list mode for this element.
   * Field access restricted because there are specific valid values.
   */
  protected listMode?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _listMode?: Element;

  /**
   * Any combination of letters, numerals, "-" and ".", with a length limit of 64 characters.  (This
   * might be an integer, an unprefixed OID, UUID or any other identifier pattern that meets these
   * constraints.)  Ids are case-insensitive.
   * Field access restricted because there are specific valid values.
   */
  protected variable?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _variable?: Element;

  /**
   * A sequence of Unicode characters
   * Field access restricted because there are specific valid values.
   */
  protected condition?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _condition?: Element;

  /**
   * A sequence of Unicode characters
   * Field access restricted because there are specific valid values.
   */
  protected check?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _check?: Element;

  /**
   * A sequence of Unicode characters
   * Field access restricted because there are specific valid values.
   */
  protected logMessage?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _logMessage?: Element;


  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setId(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.id) !== 'undefined') {
         delete this.id;
      }
      return;
    }
    
    if (REGEX_ID.test(newValue)) {
      this.id = newValue
    } else {
      throw new Error("Invalid value pattern for id of " + newValue);
    }
  }
  
  public getIdPattern(): string {
    return REGEX_ID.source;
  }
  

  public getId(): string | undefined {
      return this.id;
  }

  public addExtension(newValue: Extension) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.extension) !== 'undefined') {
         delete this.extension;
      }
      return;
    }
    
    if (typeof(this.extension) === 'undefined') {
      this.extension =  [];
    }
    this.extension.push(newValue);
  }

  public getExtension(): Extension[] | undefined {
      return this.extension;
  }

  public addModifierExtension(newValue: Extension) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.modifierExtension) !== 'undefined') {
         delete this.modifierExtension;
      }
      return;
    }
    
    if (typeof(this.modifierExtension) === 'undefined') {
      this.modifierExtension =  [];
    }
    this.modifierExtension.push(newValue);
  }

  public getModifierExtension(): Extension[] | undefined {
      return this.modifierExtension;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setContext(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.context) !== 'undefined') {
         delete this.context;
      }
      return;
    }
    
    if (REGEX_CONTEXT.test(newValue)) {
      this.context = newValue
    } else {
      throw new Error("Invalid value pattern for context of " + newValue);
    }
  }
  
  public getContextPattern(): string {
    return REGEX_CONTEXT.source;
  }
  

  public getContext(): string | undefined {
      return this.context;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setMax(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.max) !== 'undefined') {
         delete this.max;
      }
      return;
    }
    
    if (REGEX_MAX.test(newValue)) {
      this.max = newValue
    } else {
      throw new Error("Invalid value pattern for max of " + newValue);
    }
  }
  
  public getMaxPattern(): string {
    return REGEX_MAX.source;
  }
  

  public getMax(): string | undefined {
      return this.max;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setType(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.type) !== 'undefined') {
         delete this.type;
      }
      return;
    }
    
    if (REGEX_TYPE_000.test(newValue)) {
      this.type = newValue
    } else {
      throw new Error("Invalid value pattern for type of " + newValue);
    }
  }
  
  public getTypePattern(): string {
    return REGEX_TYPE_000.source;
  }
  

  public getType(): string | undefined {
      return this.type;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setDefaultValueBase64Binary(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.defaultValueBase64Binary) !== 'undefined') {
         delete this.defaultValueBase64Binary;
      }
      return;
    }
    
    if (REGEX_DEFAULTVALUEBASE64BINARY.test(newValue)) {
      this.defaultValueBase64Binary = newValue
    } else {
      throw new Error("Invalid value pattern for defaultValueBase64Binary of " + newValue);
    }
  }
  
  public getDefaultValueBase64BinaryPattern(): string {
    return REGEX_DEFAULTVALUEBASE64BINARY.source;
  }
  

  public getDefaultValueBase64Binary(): string | undefined {
      return this.defaultValueBase64Binary;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setDefaultValueCanonical(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.defaultValueCanonical) !== 'undefined') {
         delete this.defaultValueCanonical;
      }
      return;
    }
    
    if (REGEX_DEFAULTVALUECANONICAL.test(newValue)) {
      this.defaultValueCanonical = newValue
    } else {
      throw new Error("Invalid value pattern for defaultValueCanonical of " + newValue);
    }
  }
  
  public getDefaultValueCanonicalPattern(): string {
    return REGEX_DEFAULTVALUECANONICAL.source;
  }
  

  public getDefaultValueCanonical(): string | undefined {
      return this.defaultValueCanonical;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setDefaultValueCode(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.defaultValueCode) !== 'undefined') {
         delete this.defaultValueCode;
      }
      return;
    }
    
    if (REGEX_DEFAULTVALUECODE.test(newValue)) {
      this.defaultValueCode = newValue
    } else {
      throw new Error("Invalid value pattern for defaultValueCode of " + newValue);
    }
  }
  
  public getDefaultValueCodePattern(): string {
    return REGEX_DEFAULTVALUECODE.source;
  }
  

  public getDefaultValueCode(): string | undefined {
      return this.defaultValueCode;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setDefaultValueDate(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.defaultValueDate) !== 'undefined') {
         delete this.defaultValueDate;
      }
      return;
    }
    
    if (REGEX_DEFAULTVALUEDATE.test(newValue)) {
      this.defaultValueDate = newValue
    } else {
      throw new Error("Invalid value pattern for defaultValueDate of " + newValue);
    }
  }
  
  public getDefaultValueDatePattern(): string {
    return REGEX_DEFAULTVALUEDATE.source;
  }
  

  public getDefaultValueDate(): string | undefined {
      return this.defaultValueDate;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setDefaultValueDateTime(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.defaultValueDateTime) !== 'undefined') {
         delete this.defaultValueDateTime;
      }
      return;
    }
    
    if (REGEX_DEFAULTVALUEDATETIME.test(newValue)) {
      this.defaultValueDateTime = newValue
    } else {
      throw new Error("Invalid value pattern for defaultValueDateTime of " + newValue);
    }
  }
  
  public getDefaultValueDateTimePattern(): string {
    return REGEX_DEFAULTVALUEDATETIME.source;
  }
  

  public getDefaultValueDateTime(): string | undefined {
      return this.defaultValueDateTime;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setDefaultValueId(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.defaultValueId) !== 'undefined') {
         delete this.defaultValueId;
      }
      return;
    }
    
    if (REGEX_DEFAULTVALUEID.test(newValue)) {
      this.defaultValueId = newValue
    } else {
      throw new Error("Invalid value pattern for defaultValueId of " + newValue);
    }
  }
  
  public getDefaultValueIdPattern(): string {
    return REGEX_DEFAULTVALUEID.source;
  }
  

  public getDefaultValueId(): string | undefined {
      return this.defaultValueId;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setDefaultValueInstant(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.defaultValueInstant) !== 'undefined') {
         delete this.defaultValueInstant;
      }
      return;
    }
    
    if (REGEX_DEFAULTVALUEINSTANT.test(newValue)) {
      this.defaultValueInstant = newValue
    } else {
      throw new Error("Invalid value pattern for defaultValueInstant of " + newValue);
    }
  }
  
  public getDefaultValueInstantPattern(): string {
    return REGEX_DEFAULTVALUEINSTANT.source;
  }
  

  public getDefaultValueInstant(): string | undefined {
      return this.defaultValueInstant;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setDefaultValueMarkdown(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.defaultValueMarkdown) !== 'undefined') {
         delete this.defaultValueMarkdown;
      }
      return;
    }
    
    if (REGEX_DEFAULTVALUEMARKDOWN.test(newValue)) {
      this.defaultValueMarkdown = newValue
    } else {
      throw new Error("Invalid value pattern for defaultValueMarkdown of " + newValue);
    }
  }
  
  public getDefaultValueMarkdownPattern(): string {
    return REGEX_DEFAULTVALUEMARKDOWN.source;
  }
  

  public getDefaultValueMarkdown(): string | undefined {
      return this.defaultValueMarkdown;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setDefaultValueOid(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.defaultValueOid) !== 'undefined') {
         delete this.defaultValueOid;
      }
      return;
    }
    
    if (REGEX_DEFAULTVALUEOID.test(newValue)) {
      this.defaultValueOid = newValue
    } else {
      throw new Error("Invalid value pattern for defaultValueOid of " + newValue);
    }
  }
  
  public getDefaultValueOidPattern(): string {
    return REGEX_DEFAULTVALUEOID.source;
  }
  

  public getDefaultValueOid(): string | undefined {
      return this.defaultValueOid;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setDefaultValueString(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.defaultValueString) !== 'undefined') {
         delete this.defaultValueString;
      }
      return;
    }
    
    if (REGEX_DEFAULTVALUESTRING.test(newValue)) {
      this.defaultValueString = newValue
    } else {
      throw new Error("Invalid value pattern for defaultValueString of " + newValue);
    }
  }
  
  public getDefaultValueStringPattern(): string {
    return REGEX_DEFAULTVALUESTRING.source;
  }
  

  public getDefaultValueString(): string | undefined {
      return this.defaultValueString;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setDefaultValueTime(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.defaultValueTime) !== 'undefined') {
         delete this.defaultValueTime;
      }
      return;
    }
    
    if (REGEX_DEFAULTVALUETIME.test(newValue)) {
      this.defaultValueTime = newValue
    } else {
      throw new Error("Invalid value pattern for defaultValueTime of " + newValue);
    }
  }
  
  public getDefaultValueTimePattern(): string {
    return REGEX_DEFAULTVALUETIME.source;
  }
  

  public getDefaultValueTime(): string | undefined {
      return this.defaultValueTime;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setDefaultValueUri(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.defaultValueUri) !== 'undefined') {
         delete this.defaultValueUri;
      }
      return;
    }
    
    if (REGEX_DEFAULTVALUEURI.test(newValue)) {
      this.defaultValueUri = newValue
    } else {
      throw new Error("Invalid value pattern for defaultValueUri of " + newValue);
    }
  }
  
  public getDefaultValueUriPattern(): string {
    return REGEX_DEFAULTVALUEURI.source;
  }
  

  public getDefaultValueUri(): string | undefined {
      return this.defaultValueUri;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setDefaultValueUrl(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.defaultValueUrl) !== 'undefined') {
         delete this.defaultValueUrl;
      }
      return;
    }
    
    if (REGEX_DEFAULTVALUEURL.test(newValue)) {
      this.defaultValueUrl = newValue
    } else {
      throw new Error("Invalid value pattern for defaultValueUrl of " + newValue);
    }
  }
  
  public getDefaultValueUrlPattern(): string {
    return REGEX_DEFAULTVALUEURL.source;
  }
  

  public getDefaultValueUrl(): string | undefined {
      return this.defaultValueUrl;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setDefaultValueUuid(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.defaultValueUuid) !== 'undefined') {
         delete this.defaultValueUuid;
      }
      return;
    }
    
    if (REGEX_DEFAULTVALUEUUID.test(newValue)) {
      this.defaultValueUuid = newValue
    } else {
      throw new Error("Invalid value pattern for defaultValueUuid of " + newValue);
    }
  }
  
  public getDefaultValueUuidPattern(): string {
    return REGEX_DEFAULTVALUEUUID.source;
  }
  

  public getDefaultValueUuid(): string | undefined {
      return this.defaultValueUuid;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setElement(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.element) !== 'undefined') {
         delete this.element;
      }
      return;
    }
    
    if (REGEX_ELEMENT.test(newValue)) {
      this.element = newValue
    } else {
      throw new Error("Invalid value pattern for element of " + newValue);
    }
  }
  
  public getElementPattern(): string {
    return REGEX_ELEMENT.source;
  }
  

  public getElement(): string | undefined {
      return this.element;
  }

  /*
  * This sets the data ensuring that the value is valid.  If not valid, it throws an error
  * that should be caught.
  */
  public setListMode(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.listMode) !== 'undefined') {
         delete this.listMode;
      }
      return;
    }
    
    const idx = getValidValueIdx(StructureMapSourceListMode_list_ValidValues, newValue);
    if (idx >= 0) {
      this.listMode = StructureMapSourceListMode_list_ValidValues[idx];
    } else {
      throw new Error("Unknown listMode of " + newValue);
    }
  }
  
  public getStructureMapSourceListModeValidValues(): string[] {
    return StructureMapSourceListMode_list_ValidValues;
  }
  

  public getListMode(): string | undefined {
      return this.listMode;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setVariable(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.variable) !== 'undefined') {
         delete this.variable;
      }
      return;
    }
    
    if (REGEX_VARIABLE.test(newValue)) {
      this.variable = newValue
    } else {
      throw new Error("Invalid value pattern for variable of " + newValue);
    }
  }
  
  public getVariablePattern(): string {
    return REGEX_VARIABLE.source;
  }
  

  public getVariable(): string | undefined {
      return this.variable;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setCondition(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.condition) !== 'undefined') {
         delete this.condition;
      }
      return;
    }
    
    if (REGEX_CONDITION.test(newValue)) {
      this.condition = newValue
    } else {
      throw new Error("Invalid value pattern for condition of " + newValue);
    }
  }
  
  public getConditionPattern(): string {
    return REGEX_CONDITION.source;
  }
  

  public getCondition(): string | undefined {
      return this.condition;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setCheck(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.check) !== 'undefined') {
         delete this.check;
      }
      return;
    }
    
    if (REGEX_CHECK.test(newValue)) {
      this.check = newValue
    } else {
      throw new Error("Invalid value pattern for check of " + newValue);
    }
  }
  
  public getCheckPattern(): string {
    return REGEX_CHECK.source;
  }
  

  public getCheck(): string | undefined {
      return this.check;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setLogMessage(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.logMessage) !== 'undefined') {
         delete this.logMessage;
      }
      return;
    }
    
    if (REGEX_LOGMESSAGE.test(newValue)) {
      this.logMessage = newValue
    } else {
      throw new Error("Invalid value pattern for logMessage of " + newValue);
    }
  }
  
  public getLogMessagePattern(): string {
    return REGEX_LOGMESSAGE.source;
  }
  

  public getLogMessage(): string | undefined {
      return this.logMessage;
  }


}


