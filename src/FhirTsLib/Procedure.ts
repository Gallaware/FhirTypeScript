import { Type } from 'class-transformer';
import { REGEX_ID_000, REGEX_IMPLICITRULES, REGEX_LANGUAGE, REGEX_STATUS_000, REGEX_PERFORMEDDATETIME, REGEX_PERFORMEDSTRING } from '../FhirTsLibValidation/FhirRegex';
import { Age, Annotation, CodeableConcept, Element, Extension, Identifier, Meta, Narrative, Period, ProcedureFocalDevice, ProcedurePerformer, Range, Reference, ResourceList, Account, ActivityDefinition, AdverseEvent, AllergyIntolerance, Appointment, AppointmentResponse, AuditEvent, Basic, Binary, BiologicallyDerivedProduct, BodyStructure, Bundle, CapabilityStatement, CarePlan, CareTeam, CatalogEntry, ChargeItem, ChargeItemDefinition, Claim, ClaimResponse, ClinicalImpression, CodeSystem, Communication, CommunicationRequest, CompartmentDefinition, Composition, ConceptMap, Condition, Consent, Contract, Coverage, CoverageEligibilityRequest, CoverageEligibilityResponse, DetectedIssue, Device, DeviceDefinition, DeviceMetric, DeviceRequest, DeviceUseStatement, DiagnosticReport, DocumentManifest, DocumentReference, EffectEvidenceSynthesis, Encounter, Endpoint, EnrollmentRequest, EnrollmentResponse, EpisodeOfCare, EventDefinition, Evidence, EvidenceVariable, ExampleScenario, ExplanationOfBenefit, FamilyMemberHistory, Flag, Goal, GraphDefinition, Group, GuidanceResponse, HealthcareService, ImagingStudy, Immunization, ImmunizationEvaluation, ImmunizationRecommendation, ImplementationGuide, InsurancePlan, Invoice, Library, Linkage, List, Location, Measure, MeasureReport, Media, Medication, MedicationAdministration, MedicationDispense, MedicationKnowledge, MedicationRequest, MedicationStatement, MedicinalProduct, MedicinalProductAuthorization, MedicinalProductContraindication, MedicinalProductIndication, MedicinalProductIngredient, MedicinalProductInteraction, MedicinalProductManufactured, MedicinalProductPackaged, MedicinalProductPharmaceutical, MedicinalProductUndesirableEffect, MessageDefinition, MessageHeader, MolecularSequence, NamingSystem, NutritionOrder, Observation, ObservationDefinition, OperationDefinition, OperationOutcome, Organization, OrganizationAffiliation, Parameters, Patient, PaymentNotice, PaymentReconciliation, Person, PlanDefinition, Practitioner, PractitionerRole, Provenance, Questionnaire, QuestionnaireResponse, RelatedPerson, RequestGroup, ResearchDefinition, ResearchElementDefinition, ResearchStudy, ResearchSubject, RiskAssessment, RiskEvidenceSynthesis, Schedule, SearchParameter, ServiceRequest, Slot, Specimen, SpecimenDefinition, StructureDefinition, StructureMap, Subscription, Substance, SubstanceNucleicAcid, SubstancePolymer, SubstanceProtein, SubstanceReferenceInformation, SubstanceSourceMaterial, SubstanceSpecification, SupplyDelivery, SupplyRequest, Task, TerminologyCapabilities, TestReport, TestScript, ValueSet, VerificationResult, VisionPrescription } from './index';



/**
 * An action that is or was performed on or for a patient. This can be a physical intervention like an
 * operation, or less invasive like long term services, counseling, or hypnotherapy.
 *
 * Generated by Gallaware, Inc. from:
 *    file:/Users/admin/Documents/DevNetbeans/jsonSchemaToJava/target/classes/schema/fhir.schema.json#/definitions/Procedure
 */
export class Procedure {
  /**
   * This is a Procedure resource
   */
     resourceType = "Procedure";

  /**
   * Any combination of letters, numerals, "-" and ".", with a length limit of 64 characters.  (This
   * might be an integer, an unprefixed OID, UUID or any other identifier pattern that meets these
   * constraints.)  Ids are case-insensitive.
   * Field access restricted because there are specific valid values.
   */
  protected id?: string;

  /**
   * The metadata about a resource. This is content in the resource that is maintained by the
   * infrastructure. Changes to the content might not always be associated with version changes to the
   * resource.
   */
  @Type(() => Meta)
   meta?: Meta;

  /**
   * String of characters used to identify a name or a resource
   * Field access restricted because there are specific valid values.
   */
  protected implicitRules?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _implicitRules?: Element;

  /**
   * A string which has at least one character and no leading or trailing whitespace and where there is
   * no whitespace other than single spaces in the contents
   * Field access restricted because there are specific valid values.
   */
  protected language?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _language?: Element;

  /**
   * A human-readable summary of the resource conveying the essential clinical and business information
   * for the resource.
   */
  @Type(() => Narrative)
   text?: Narrative;

  /**
   * These resources do not have an independent existence apart from the resource that contains them -
   * they cannot be identified independently, and nor can they have their own independent transaction
   * scope.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => ResourceList, {
          discriminator: {
    property: 'resourceType',
    subTypes: [
      	{ value: Account, name: 'Account'},
      	{ value: ActivityDefinition, name: 'ActivityDefinition'},
      	{ value: AdverseEvent, name: 'AdverseEvent'},
      	{ value: AllergyIntolerance, name: 'AllergyIntolerance'},
      	{ value: Appointment, name: 'Appointment'},
      	{ value: AppointmentResponse, name: 'AppointmentResponse'},
      	{ value: AuditEvent, name: 'AuditEvent'},
      	{ value: Basic, name: 'Basic'},
      	{ value: Binary, name: 'Binary'},
      	{ value: BiologicallyDerivedProduct, name: 'BiologicallyDerivedProduct'},
      	{ value: BodyStructure, name: 'BodyStructure'},
      	{ value: Bundle, name: 'Bundle'},
      	{ value: CapabilityStatement, name: 'CapabilityStatement'},
      	{ value: CarePlan, name: 'CarePlan'},
      	{ value: CareTeam, name: 'CareTeam'},
      	{ value: CatalogEntry, name: 'CatalogEntry'},
      	{ value: ChargeItem, name: 'ChargeItem'},
      	{ value: ChargeItemDefinition, name: 'ChargeItemDefinition'},
      	{ value: Claim, name: 'Claim'},
      	{ value: ClaimResponse, name: 'ClaimResponse'},
      	{ value: ClinicalImpression, name: 'ClinicalImpression'},
      	{ value: CodeSystem, name: 'CodeSystem'},
      	{ value: Communication, name: 'Communication'},
      	{ value: CommunicationRequest, name: 'CommunicationRequest'},
      	{ value: CompartmentDefinition, name: 'CompartmentDefinition'},
      	{ value: Composition, name: 'Composition'},
      	{ value: ConceptMap, name: 'ConceptMap'},
      	{ value: Condition, name: 'Condition'},
      	{ value: Consent, name: 'Consent'},
      	{ value: Contract, name: 'Contract'},
      	{ value: Coverage, name: 'Coverage'},
      	{ value: CoverageEligibilityRequest, name: 'CoverageEligibilityRequest'},
      	{ value: CoverageEligibilityResponse, name: 'CoverageEligibilityResponse'},
      	{ value: DetectedIssue, name: 'DetectedIssue'},
      	{ value: Device, name: 'Device'},
      	{ value: DeviceDefinition, name: 'DeviceDefinition'},
      	{ value: DeviceMetric, name: 'DeviceMetric'},
      	{ value: DeviceRequest, name: 'DeviceRequest'},
      	{ value: DeviceUseStatement, name: 'DeviceUseStatement'},
      	{ value: DiagnosticReport, name: 'DiagnosticReport'},
      	{ value: DocumentManifest, name: 'DocumentManifest'},
      	{ value: DocumentReference, name: 'DocumentReference'},
      	{ value: EffectEvidenceSynthesis, name: 'EffectEvidenceSynthesis'},
      	{ value: Encounter, name: 'Encounter'},
      	{ value: Endpoint, name: 'Endpoint'},
      	{ value: EnrollmentRequest, name: 'EnrollmentRequest'},
      	{ value: EnrollmentResponse, name: 'EnrollmentResponse'},
      	{ value: EpisodeOfCare, name: 'EpisodeOfCare'},
      	{ value: EventDefinition, name: 'EventDefinition'},
      	{ value: Evidence, name: 'Evidence'},
      	{ value: EvidenceVariable, name: 'EvidenceVariable'},
      	{ value: ExampleScenario, name: 'ExampleScenario'},
      	{ value: ExplanationOfBenefit, name: 'ExplanationOfBenefit'},
      	{ value: FamilyMemberHistory, name: 'FamilyMemberHistory'},
      	{ value: Flag, name: 'Flag'},
      	{ value: Goal, name: 'Goal'},
      	{ value: GraphDefinition, name: 'GraphDefinition'},
      	{ value: Group, name: 'Group'},
      	{ value: GuidanceResponse, name: 'GuidanceResponse'},
      	{ value: HealthcareService, name: 'HealthcareService'},
      	{ value: ImagingStudy, name: 'ImagingStudy'},
      	{ value: Immunization, name: 'Immunization'},
      	{ value: ImmunizationEvaluation, name: 'ImmunizationEvaluation'},
      	{ value: ImmunizationRecommendation, name: 'ImmunizationRecommendation'},
      	{ value: ImplementationGuide, name: 'ImplementationGuide'},
      	{ value: InsurancePlan, name: 'InsurancePlan'},
      	{ value: Invoice, name: 'Invoice'},
      	{ value: Library, name: 'Library'},
      	{ value: Linkage, name: 'Linkage'},
      	{ value: List, name: 'List'},
      	{ value: Location, name: 'Location'},
      	{ value: Measure, name: 'Measure'},
      	{ value: MeasureReport, name: 'MeasureReport'},
      	{ value: Media, name: 'Media'},
      	{ value: Medication, name: 'Medication'},
      	{ value: MedicationAdministration, name: 'MedicationAdministration'},
      	{ value: MedicationDispense, name: 'MedicationDispense'},
      	{ value: MedicationKnowledge, name: 'MedicationKnowledge'},
      	{ value: MedicationRequest, name: 'MedicationRequest'},
      	{ value: MedicationStatement, name: 'MedicationStatement'},
      	{ value: MedicinalProduct, name: 'MedicinalProduct'},
      	{ value: MedicinalProductAuthorization, name: 'MedicinalProductAuthorization'},
      	{ value: MedicinalProductContraindication, name: 'MedicinalProductContraindication'},
      	{ value: MedicinalProductIndication, name: 'MedicinalProductIndication'},
      	{ value: MedicinalProductIngredient, name: 'MedicinalProductIngredient'},
      	{ value: MedicinalProductInteraction, name: 'MedicinalProductInteraction'},
      	{ value: MedicinalProductManufactured, name: 'MedicinalProductManufactured'},
      	{ value: MedicinalProductPackaged, name: 'MedicinalProductPackaged'},
      	{ value: MedicinalProductPharmaceutical, name: 'MedicinalProductPharmaceutical'},
      	{ value: MedicinalProductUndesirableEffect, name: 'MedicinalProductUndesirableEffect'},
      	{ value: MessageDefinition, name: 'MessageDefinition'},
      	{ value: MessageHeader, name: 'MessageHeader'},
      	{ value: MolecularSequence, name: 'MolecularSequence'},
      	{ value: NamingSystem, name: 'NamingSystem'},
      	{ value: NutritionOrder, name: 'NutritionOrder'},
      	{ value: Observation, name: 'Observation'},
      	{ value: ObservationDefinition, name: 'ObservationDefinition'},
      	{ value: OperationDefinition, name: 'OperationDefinition'},
      	{ value: OperationOutcome, name: 'OperationOutcome'},
      	{ value: Organization, name: 'Organization'},
      	{ value: OrganizationAffiliation, name: 'OrganizationAffiliation'},
      	{ value: Parameters, name: 'Parameters'},
      	{ value: Patient, name: 'Patient'},
      	{ value: PaymentNotice, name: 'PaymentNotice'},
      	{ value: PaymentReconciliation, name: 'PaymentReconciliation'},
      	{ value: Person, name: 'Person'},
      	{ value: PlanDefinition, name: 'PlanDefinition'},
      	{ value: Practitioner, name: 'Practitioner'},
      	{ value: PractitionerRole, name: 'PractitionerRole'},
      	{ value: Procedure, name: 'Procedure'},
      	{ value: Provenance, name: 'Provenance'},
      	{ value: Questionnaire, name: 'Questionnaire'},
      	{ value: QuestionnaireResponse, name: 'QuestionnaireResponse'},
      	{ value: RelatedPerson, name: 'RelatedPerson'},
      	{ value: RequestGroup, name: 'RequestGroup'},
      	{ value: ResearchDefinition, name: 'ResearchDefinition'},
      	{ value: ResearchElementDefinition, name: 'ResearchElementDefinition'},
      	{ value: ResearchStudy, name: 'ResearchStudy'},
      	{ value: ResearchSubject, name: 'ResearchSubject'},
      	{ value: RiskAssessment, name: 'RiskAssessment'},
      	{ value: RiskEvidenceSynthesis, name: 'RiskEvidenceSynthesis'},
      	{ value: Schedule, name: 'Schedule'},
      	{ value: SearchParameter, name: 'SearchParameter'},
      	{ value: ServiceRequest, name: 'ServiceRequest'},
      	{ value: Slot, name: 'Slot'},
      	{ value: Specimen, name: 'Specimen'},
      	{ value: SpecimenDefinition, name: 'SpecimenDefinition'},
      	{ value: StructureDefinition, name: 'StructureDefinition'},
      	{ value: StructureMap, name: 'StructureMap'},
      	{ value: Subscription, name: 'Subscription'},
      	{ value: Substance, name: 'Substance'},
      	{ value: SubstanceNucleicAcid, name: 'SubstanceNucleicAcid'},
      	{ value: SubstancePolymer, name: 'SubstancePolymer'},
      	{ value: SubstanceProtein, name: 'SubstanceProtein'},
      	{ value: SubstanceReferenceInformation, name: 'SubstanceReferenceInformation'},
      	{ value: SubstanceSourceMaterial, name: 'SubstanceSourceMaterial'},
      	{ value: SubstanceSpecification, name: 'SubstanceSpecification'},
      	{ value: SupplyDelivery, name: 'SupplyDelivery'},
      	{ value: SupplyRequest, name: 'SupplyRequest'},
      	{ value: Task, name: 'Task'},
      	{ value: TerminologyCapabilities, name: 'TerminologyCapabilities'},
      	{ value: TestReport, name: 'TestReport'},
      	{ value: TestScript, name: 'TestScript'},
      	{ value: ValueSet, name: 'ValueSet'},
      	{ value: VerificationResult, name: 'VerificationResult'},
      	{ value: VisionPrescription, name: 'VisionPrescription'}
      ],
    }
  })
  protected contained?: ResourceList[];

  /**
   * May be used to represent additional information that is not part of the basic definition of the
   * resource. To make the use of extensions safe and manageable, there is a strict set of governance
   * applied to the definition and use of extensions. Though any implementer can define an extension,
   * there is a set of requirements that SHALL be met as part of the definition of the extension.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Extension)
  protected extension?: Extension[];

  /**
   * May be used to represent additional information that is not part of the basic definition of the
   * resource and that modifies the understanding of the element that contains it and/or the
   * understanding of the containing element's descendants. Usually modifier elements provide negation
   * or qualification. To make the use of extensions safe and manageable, there is a strict set of
   * governance applied to the definition and use of extensions. Though any implementer is allowed to
   * define an extension, there is a set of requirements that SHALL be met as part of the definition of
   * the extension. Applications processing a resource are required to check for modifier extensions.
   * 
   * Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource
   * (including cannot change the meaning of modifierExtension itself).
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Extension)
  protected modifierExtension?: Extension[];

  /**
   * Business identifiers assigned to this procedure by the performer or other systems which remain
   * constant as the resource is updated and is propagated from server to server.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Identifier)
  protected identifier?: Identifier[];

  /**
   * The URL pointing to a FHIR-defined protocol, guideline, order set or other definition that is
   * adhered to in whole or in part by this Procedure.
   * Field access restricted because there are specific valid values.
   */
  protected instantiatesCanonical?: string[];

  /**
   * The URL pointing to an externally maintained protocol, guideline, order set or other definition
   * that is adhered to in whole or in part by this Procedure.
   * Field access restricted because there are specific valid values.
   */
  protected instantiatesUri?: string[];

  /**
   * Extensions for instantiatesUri
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Element)
  protected _instantiatesUri?: Element[];

  /**
   * A reference to a resource that contains details of the request for this procedure.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Reference)
  protected basedOn?: Reference[];

  /**
   * A larger event of which this particular procedure is a component or step.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Reference)
  protected partOf?: Reference[];

  /**
   * A string which has at least one character and no leading or trailing whitespace and where there is
   * no whitespace other than single spaces in the contents
   * Field access restricted because there are specific valid values.
   */
  protected status?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _status?: Element;

  /**
   * A concept that may be defined by a formal reference to a terminology or ontology or may be provided
   * by text.
   */
  @Type(() => CodeableConcept)
   statusReason?: CodeableConcept;

  /**
   * A concept that may be defined by a formal reference to a terminology or ontology or may be provided
   * by text.
   */
  @Type(() => CodeableConcept)
   category?: CodeableConcept;

  /**
   * A concept that may be defined by a formal reference to a terminology or ontology or may be provided
   * by text.
   */
  @Type(() => CodeableConcept)
   code?: CodeableConcept;

  /**
   * A reference from one resource to another.
   */
  @Type(() => Reference)
   subject?: Reference;

  /**
   * A reference from one resource to another.
   */
  @Type(() => Reference)
   encounter?: Reference;

  /**
   * Estimated or actual date, date-time, period, or age when the procedure was performed.  Allows a
   * period to support complex procedures that span more than one date, and also allows for the length
   * of the procedure to be captured.
   * Field access restricted because there are specific valid values.
   */
  protected performedDateTime?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _performedDateTime?: Element;

  /**
   * A time period defined by a start and end date and optionally time.
   */
  @Type(() => Period)
   performedPeriod?: Period;

  /**
   * Estimated or actual date, date-time, period, or age when the procedure was performed.  Allows a
   * period to support complex procedures that span more than one date, and also allows for the length
   * of the procedure to be captured.
   * Field access restricted because there are specific valid values.
   */
  protected performedString?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _performedString?: Element;

  /**
   * A duration of time during which an organism (or a process) has existed.
   */
  @Type(() => Age)
   performedAge?: Age;

  /**
   * A set of ordered Quantities defined by a low and high limit.
   */
  @Type(() => Range)
   performedRange?: Range;

  /**
   * A reference from one resource to another.
   */
  @Type(() => Reference)
   recorder?: Reference;

  /**
   * A reference from one resource to another.
   */
  @Type(() => Reference)
   asserter?: Reference;

  /**
   * Limited to "real" people rather than equipment.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => ProcedurePerformer)
  protected performer?: ProcedurePerformer[];

  /**
   * A reference from one resource to another.
   */
  @Type(() => Reference)
   location?: Reference;

  /**
   * The coded reason why the procedure was performed. This may be a coded entity of some type, or may
   * simply be present as text.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => CodeableConcept)
  protected reasonCode?: CodeableConcept[];

  /**
   * The justification of why the procedure was performed.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Reference)
  protected reasonReference?: Reference[];

  /**
   * Detailed and structured anatomical location information. Multiple locations are allowed - e.g.
   * multiple punch biopsies of a lesion.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => CodeableConcept)
  protected bodySite?: CodeableConcept[];

  /**
   * A concept that may be defined by a formal reference to a terminology or ontology or may be provided
   * by text.
   */
  @Type(() => CodeableConcept)
   outcome?: CodeableConcept;

  /**
   * This could be a histology result, pathology report, surgical report, etc.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Reference)
  protected report?: Reference[];

  /**
   * Any complications that occurred during the procedure, or in the immediate post-performance period.
   * These are generally tracked separately from the notes, which will typically describe the procedure
   * itself rather than any 'post procedure' issues.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => CodeableConcept)
  protected complication?: CodeableConcept[];

  /**
   * Any complications that occurred during the procedure, or in the immediate post-performance period.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Reference)
  protected complicationDetail?: Reference[];

  /**
   * If the procedure required specific follow up - e.g. removal of sutures. The follow up may be
   * represented as a simple note or could potentially be more complex, in which case the CarePlan
   * resource can be used.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => CodeableConcept)
  protected followUp?: CodeableConcept[];

  /**
   * Any other notes and comments about the procedure.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Annotation)
  protected note?: Annotation[];

  /**
   * A device that is implanted, removed or otherwise manipulated (calibration, battery replacement,
   * fitting a prosthesis, attaching a wound-vac, etc.) as a focal portion of the Procedure.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => ProcedureFocalDevice)
  protected focalDevice?: ProcedureFocalDevice[];

  /**
   * Identifies medications, devices and any other substance used as part of the procedure.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Reference)
  protected usedReference?: Reference[];

  /**
   * Identifies coded items that were used as part of the procedure.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => CodeableConcept)
  protected usedCode?: CodeableConcept[];


  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setId(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.id) !== 'undefined') {
         delete this.id;
      }
      return;
    }
    
    if (REGEX_ID_000.test(newValue)) {
      this.id = newValue
    } else {
      throw new Error("Invalid value pattern for id of " + newValue);
    }
  }
  
  public getIdPattern(): string {
    return REGEX_ID_000.source;
  }
  
  /**
  * Gets the current value of field id.
  * @returns the value  or undefined
  */
  public getId(): string | undefined {
      return this.id;
  }

  /**
  * Gets the current value of field id if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getIdOrElse(defaultValue: string): string {
      if (this.id == undefined || this.id == null ) { return defaultValue; }
      return this.id;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setImplicitRules(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.implicitRules) !== 'undefined') {
         delete this.implicitRules;
      }
      return;
    }
    
    if (REGEX_IMPLICITRULES.test(newValue)) {
      this.implicitRules = newValue
    } else {
      throw new Error("Invalid value pattern for implicitRules of " + newValue);
    }
  }
  
  public getImplicitRulesPattern(): string {
    return REGEX_IMPLICITRULES.source;
  }
  
  /**
  * Gets the current value of field implicitRules.
  * @returns the value  or undefined
  */
  public getImplicitRules(): string | undefined {
      return this.implicitRules;
  }

  /**
  * Gets the current value of field implicitRules if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getImplicitRulesOrElse(defaultValue: string): string {
      if (this.implicitRules == undefined || this.implicitRules == null ) { return defaultValue; }
      return this.implicitRules;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setLanguage(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.language) !== 'undefined') {
         delete this.language;
      }
      return;
    }
    
    if (REGEX_LANGUAGE.test(newValue)) {
      this.language = newValue
    } else {
      throw new Error("Invalid value pattern for language of " + newValue);
    }
  }
  
  public getLanguagePattern(): string {
    return REGEX_LANGUAGE.source;
  }
  
  /**
  * Gets the current value of field language.
  * @returns the value  or undefined
  */
  public getLanguage(): string | undefined {
      return this.language;
  }

  /**
  * Gets the current value of field language if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getLanguageOrElse(defaultValue: string): string {
      if (this.language == undefined || this.language == null ) { return defaultValue; }
      return this.language;
  }

  public addContained(newValue: ResourceList) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.contained) !== 'undefined') {
         delete this.contained;
      }
      return;
    }
    
    if (typeof(this.contained) === 'undefined') {
      this.contained =  [];
    }
    this.contained.push(newValue);
  }
  /**
  * Removes all elements from the array contained, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteContainedAll(): ResourceList[] {
    if (typeof(this.contained) !== 'undefined') {
       const oldArray = this.contained;
       delete this.contained;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array contained, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteContainedBySplice(start: number, deleteCount?: number): ResourceList[] {
    if (typeof(this.contained) !== 'undefined') {
       return this.contained.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field contained.
  * @returns the value  or undefined
  */
  public getContained(): ResourceList[] | undefined {
      return this.contained;
  }

  /**
  * Gets the current value of field contained if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getContainedOrElse(defaultValue: ResourceList[]): ResourceList[] {
      if (this.contained == undefined || this.contained == null ) { return defaultValue; }
      return this.contained;
  }

  public addExtension(newValue: Extension) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.extension) !== 'undefined') {
         delete this.extension;
      }
      return;
    }
    
    if (typeof(this.extension) === 'undefined') {
      this.extension =  [];
    }
    this.extension.push(newValue);
  }
  /**
  * Removes all elements from the array extension, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteExtensionAll(): Extension[] {
    if (typeof(this.extension) !== 'undefined') {
       const oldArray = this.extension;
       delete this.extension;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array extension, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteExtensionBySplice(start: number, deleteCount?: number): Extension[] {
    if (typeof(this.extension) !== 'undefined') {
       return this.extension.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field extension.
  * @returns the value  or undefined
  */
  public getExtension(): Extension[] | undefined {
      return this.extension;
  }

  /**
  * Gets the current value of field extension if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getExtensionOrElse(defaultValue: Extension[]): Extension[] {
      if (this.extension == undefined || this.extension == null ) { return defaultValue; }
      return this.extension;
  }

  public addModifierExtension(newValue: Extension) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.modifierExtension) !== 'undefined') {
         delete this.modifierExtension;
      }
      return;
    }
    
    if (typeof(this.modifierExtension) === 'undefined') {
      this.modifierExtension =  [];
    }
    this.modifierExtension.push(newValue);
  }
  /**
  * Removes all elements from the array modifierExtension, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteModifierExtensionAll(): Extension[] {
    if (typeof(this.modifierExtension) !== 'undefined') {
       const oldArray = this.modifierExtension;
       delete this.modifierExtension;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array modifierExtension, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteModifierExtensionBySplice(start: number, deleteCount?: number): Extension[] {
    if (typeof(this.modifierExtension) !== 'undefined') {
       return this.modifierExtension.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field modifierExtension.
  * @returns the value  or undefined
  */
  public getModifierExtension(): Extension[] | undefined {
      return this.modifierExtension;
  }

  /**
  * Gets the current value of field modifierExtension if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getModifierExtensionOrElse(defaultValue: Extension[]): Extension[] {
      if (this.modifierExtension == undefined || this.modifierExtension == null ) { return defaultValue; }
      return this.modifierExtension;
  }

  public addIdentifier(newValue: Identifier) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.identifier) !== 'undefined') {
         delete this.identifier;
      }
      return;
    }
    
    if (typeof(this.identifier) === 'undefined') {
      this.identifier =  [];
    }
    this.identifier.push(newValue);
  }
  /**
  * Removes all elements from the array identifier, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteIdentifierAll(): Identifier[] {
    if (typeof(this.identifier) !== 'undefined') {
       const oldArray = this.identifier;
       delete this.identifier;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array identifier, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteIdentifierBySplice(start: number, deleteCount?: number): Identifier[] {
    if (typeof(this.identifier) !== 'undefined') {
       return this.identifier.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field identifier.
  * @returns the value  or undefined
  */
  public getIdentifier(): Identifier[] | undefined {
      return this.identifier;
  }

  /**
  * Gets the current value of field identifier if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getIdentifierOrElse(defaultValue: Identifier[]): Identifier[] {
      if (this.identifier == undefined || this.identifier == null ) { return defaultValue; }
      return this.identifier;
  }

  public addInstantiatesCanonical(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.instantiatesCanonical) !== 'undefined') {
         delete this.instantiatesCanonical;
      }
      return;
    }
    
    if (typeof(this.instantiatesCanonical) === 'undefined') {
      this.instantiatesCanonical =  [];
    }
    this.instantiatesCanonical.push(newValue);
  }
  /**
  * Removes all elements from the array instantiatesCanonical, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteInstantiatesCanonicalAll(): string[] {
    if (typeof(this.instantiatesCanonical) !== 'undefined') {
       const oldArray = this.instantiatesCanonical;
       delete this.instantiatesCanonical;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array instantiatesCanonical, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteInstantiatesCanonicalBySplice(start: number, deleteCount?: number): string[] {
    if (typeof(this.instantiatesCanonical) !== 'undefined') {
       return this.instantiatesCanonical.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field instantiatesCanonical.
  * @returns the value  or undefined
  */
  public getInstantiatesCanonical(): string[] | undefined {
      return this.instantiatesCanonical;
  }

  /**
  * Gets the current value of field instantiatesCanonical if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getInstantiatesCanonicalOrElse(defaultValue: string[]): string[] {
      if (this.instantiatesCanonical == undefined || this.instantiatesCanonical == null ) { return defaultValue; }
      return this.instantiatesCanonical;
  }

  public addInstantiatesUri(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.instantiatesUri) !== 'undefined') {
         delete this.instantiatesUri;
      }
      return;
    }
    
    if (typeof(this.instantiatesUri) === 'undefined') {
      this.instantiatesUri =  [];
    }
    this.instantiatesUri.push(newValue);
  }
  /**
  * Removes all elements from the array instantiatesUri, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteInstantiatesUriAll(): string[] {
    if (typeof(this.instantiatesUri) !== 'undefined') {
       const oldArray = this.instantiatesUri;
       delete this.instantiatesUri;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array instantiatesUri, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteInstantiatesUriBySplice(start: number, deleteCount?: number): string[] {
    if (typeof(this.instantiatesUri) !== 'undefined') {
       return this.instantiatesUri.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field instantiatesUri.
  * @returns the value  or undefined
  */
  public getInstantiatesUri(): string[] | undefined {
      return this.instantiatesUri;
  }

  /**
  * Gets the current value of field instantiatesUri if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getInstantiatesUriOrElse(defaultValue: string[]): string[] {
      if (this.instantiatesUri == undefined || this.instantiatesUri == null ) { return defaultValue; }
      return this.instantiatesUri;
  }

  public add_instantiatesUri(newValue: Element) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this._instantiatesUri) !== 'undefined') {
         delete this._instantiatesUri;
      }
      return;
    }
    
    if (typeof(this._instantiatesUri) === 'undefined') {
      this._instantiatesUri =  [];
    }
    this._instantiatesUri.push(newValue);
  }
  /**
  * Removes all elements from the array _instantiatesUri, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public delete_instantiatesUriAll(): Element[] {
    if (typeof(this._instantiatesUri) !== 'undefined') {
       const oldArray = this._instantiatesUri;
       delete this._instantiatesUri;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array _instantiatesUri, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public delete_instantiatesUriBySplice(start: number, deleteCount?: number): Element[] {
    if (typeof(this._instantiatesUri) !== 'undefined') {
       return this._instantiatesUri.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field _instantiatesUri.
  * @returns the value  or undefined
  */
  public get_instantiatesUri(): Element[] | undefined {
      return this._instantiatesUri;
  }

  /**
  * Gets the current value of field _instantiatesUri if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public get_instantiatesUriOrElse(defaultValue: Element[]): Element[] {
      if (this._instantiatesUri == undefined || this._instantiatesUri == null ) { return defaultValue; }
      return this._instantiatesUri;
  }

  public addBasedOn(newValue: Reference) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.basedOn) !== 'undefined') {
         delete this.basedOn;
      }
      return;
    }
    
    if (typeof(this.basedOn) === 'undefined') {
      this.basedOn =  [];
    }
    this.basedOn.push(newValue);
  }
  /**
  * Removes all elements from the array basedOn, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteBasedOnAll(): Reference[] {
    if (typeof(this.basedOn) !== 'undefined') {
       const oldArray = this.basedOn;
       delete this.basedOn;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array basedOn, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteBasedOnBySplice(start: number, deleteCount?: number): Reference[] {
    if (typeof(this.basedOn) !== 'undefined') {
       return this.basedOn.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field basedOn.
  * @returns the value  or undefined
  */
  public getBasedOn(): Reference[] | undefined {
      return this.basedOn;
  }

  /**
  * Gets the current value of field basedOn if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getBasedOnOrElse(defaultValue: Reference[]): Reference[] {
      if (this.basedOn == undefined || this.basedOn == null ) { return defaultValue; }
      return this.basedOn;
  }

  public addPartOf(newValue: Reference) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.partOf) !== 'undefined') {
         delete this.partOf;
      }
      return;
    }
    
    if (typeof(this.partOf) === 'undefined') {
      this.partOf =  [];
    }
    this.partOf.push(newValue);
  }
  /**
  * Removes all elements from the array partOf, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deletePartOfAll(): Reference[] {
    if (typeof(this.partOf) !== 'undefined') {
       const oldArray = this.partOf;
       delete this.partOf;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array partOf, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deletePartOfBySplice(start: number, deleteCount?: number): Reference[] {
    if (typeof(this.partOf) !== 'undefined') {
       return this.partOf.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field partOf.
  * @returns the value  or undefined
  */
  public getPartOf(): Reference[] | undefined {
      return this.partOf;
  }

  /**
  * Gets the current value of field partOf if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getPartOfOrElse(defaultValue: Reference[]): Reference[] {
      if (this.partOf == undefined || this.partOf == null ) { return defaultValue; }
      return this.partOf;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setStatus(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.status) !== 'undefined') {
         delete this.status;
      }
      return;
    }
    
    if (REGEX_STATUS_000.test(newValue)) {
      this.status = newValue
    } else {
      throw new Error("Invalid value pattern for status of " + newValue);
    }
  }
  
  public getStatusPattern(): string {
    return REGEX_STATUS_000.source;
  }
  
  /**
  * Gets the current value of field status.
  * @returns the value  or undefined
  */
  public getStatus(): string | undefined {
      return this.status;
  }

  /**
  * Gets the current value of field status if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getStatusOrElse(defaultValue: string): string {
      if (this.status == undefined || this.status == null ) { return defaultValue; }
      return this.status;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setPerformedDateTime(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.performedDateTime) !== 'undefined') {
         delete this.performedDateTime;
      }
      return;
    }
    
    if (REGEX_PERFORMEDDATETIME.test(newValue)) {
      this.performedDateTime = newValue
    } else {
      throw new Error("Invalid value pattern for performedDateTime of " + newValue);
    }
  }
  
  public getPerformedDateTimePattern(): string {
    return REGEX_PERFORMEDDATETIME.source;
  }
  
  /**
  * Gets the current value of field performedDateTime.
  * @returns the value  or undefined
  */
  public getPerformedDateTime(): string | undefined {
      return this.performedDateTime;
  }

  /**
  * Gets the current value of field performedDateTime if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getPerformedDateTimeOrElse(defaultValue: string): string {
      if (this.performedDateTime == undefined || this.performedDateTime == null ) { return defaultValue; }
      return this.performedDateTime;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setPerformedString(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.performedString) !== 'undefined') {
         delete this.performedString;
      }
      return;
    }
    
    if (REGEX_PERFORMEDSTRING.test(newValue)) {
      this.performedString = newValue
    } else {
      throw new Error("Invalid value pattern for performedString of " + newValue);
    }
  }
  
  public getPerformedStringPattern(): string {
    return REGEX_PERFORMEDSTRING.source;
  }
  
  /**
  * Gets the current value of field performedString.
  * @returns the value  or undefined
  */
  public getPerformedString(): string | undefined {
      return this.performedString;
  }

  /**
  * Gets the current value of field performedString if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getPerformedStringOrElse(defaultValue: string): string {
      if (this.performedString == undefined || this.performedString == null ) { return defaultValue; }
      return this.performedString;
  }

  public addPerformer(newValue: ProcedurePerformer) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.performer) !== 'undefined') {
         delete this.performer;
      }
      return;
    }
    
    if (typeof(this.performer) === 'undefined') {
      this.performer =  [];
    }
    this.performer.push(newValue);
  }
  /**
  * Removes all elements from the array performer, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deletePerformerAll(): ProcedurePerformer[] {
    if (typeof(this.performer) !== 'undefined') {
       const oldArray = this.performer;
       delete this.performer;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array performer, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deletePerformerBySplice(start: number, deleteCount?: number): ProcedurePerformer[] {
    if (typeof(this.performer) !== 'undefined') {
       return this.performer.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field performer.
  * @returns the value  or undefined
  */
  public getPerformer(): ProcedurePerformer[] | undefined {
      return this.performer;
  }

  /**
  * Gets the current value of field performer if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getPerformerOrElse(defaultValue: ProcedurePerformer[]): ProcedurePerformer[] {
      if (this.performer == undefined || this.performer == null ) { return defaultValue; }
      return this.performer;
  }

  public addReasonCode(newValue: CodeableConcept) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.reasonCode) !== 'undefined') {
         delete this.reasonCode;
      }
      return;
    }
    
    if (typeof(this.reasonCode) === 'undefined') {
      this.reasonCode =  [];
    }
    this.reasonCode.push(newValue);
  }
  /**
  * Removes all elements from the array reasonCode, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteReasonCodeAll(): CodeableConcept[] {
    if (typeof(this.reasonCode) !== 'undefined') {
       const oldArray = this.reasonCode;
       delete this.reasonCode;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array reasonCode, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteReasonCodeBySplice(start: number, deleteCount?: number): CodeableConcept[] {
    if (typeof(this.reasonCode) !== 'undefined') {
       return this.reasonCode.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field reasonCode.
  * @returns the value  or undefined
  */
  public getReasonCode(): CodeableConcept[] | undefined {
      return this.reasonCode;
  }

  /**
  * Gets the current value of field reasonCode if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getReasonCodeOrElse(defaultValue: CodeableConcept[]): CodeableConcept[] {
      if (this.reasonCode == undefined || this.reasonCode == null ) { return defaultValue; }
      return this.reasonCode;
  }

  public addReasonReference(newValue: Reference) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.reasonReference) !== 'undefined') {
         delete this.reasonReference;
      }
      return;
    }
    
    if (typeof(this.reasonReference) === 'undefined') {
      this.reasonReference =  [];
    }
    this.reasonReference.push(newValue);
  }
  /**
  * Removes all elements from the array reasonReference, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteReasonReferenceAll(): Reference[] {
    if (typeof(this.reasonReference) !== 'undefined') {
       const oldArray = this.reasonReference;
       delete this.reasonReference;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array reasonReference, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteReasonReferenceBySplice(start: number, deleteCount?: number): Reference[] {
    if (typeof(this.reasonReference) !== 'undefined') {
       return this.reasonReference.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field reasonReference.
  * @returns the value  or undefined
  */
  public getReasonReference(): Reference[] | undefined {
      return this.reasonReference;
  }

  /**
  * Gets the current value of field reasonReference if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getReasonReferenceOrElse(defaultValue: Reference[]): Reference[] {
      if (this.reasonReference == undefined || this.reasonReference == null ) { return defaultValue; }
      return this.reasonReference;
  }

  public addBodySite(newValue: CodeableConcept) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.bodySite) !== 'undefined') {
         delete this.bodySite;
      }
      return;
    }
    
    if (typeof(this.bodySite) === 'undefined') {
      this.bodySite =  [];
    }
    this.bodySite.push(newValue);
  }
  /**
  * Removes all elements from the array bodySite, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteBodySiteAll(): CodeableConcept[] {
    if (typeof(this.bodySite) !== 'undefined') {
       const oldArray = this.bodySite;
       delete this.bodySite;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array bodySite, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteBodySiteBySplice(start: number, deleteCount?: number): CodeableConcept[] {
    if (typeof(this.bodySite) !== 'undefined') {
       return this.bodySite.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field bodySite.
  * @returns the value  or undefined
  */
  public getBodySite(): CodeableConcept[] | undefined {
      return this.bodySite;
  }

  /**
  * Gets the current value of field bodySite if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getBodySiteOrElse(defaultValue: CodeableConcept[]): CodeableConcept[] {
      if (this.bodySite == undefined || this.bodySite == null ) { return defaultValue; }
      return this.bodySite;
  }

  public addReport(newValue: Reference) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.report) !== 'undefined') {
         delete this.report;
      }
      return;
    }
    
    if (typeof(this.report) === 'undefined') {
      this.report =  [];
    }
    this.report.push(newValue);
  }
  /**
  * Removes all elements from the array report, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteReportAll(): Reference[] {
    if (typeof(this.report) !== 'undefined') {
       const oldArray = this.report;
       delete this.report;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array report, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteReportBySplice(start: number, deleteCount?: number): Reference[] {
    if (typeof(this.report) !== 'undefined') {
       return this.report.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field report.
  * @returns the value  or undefined
  */
  public getReport(): Reference[] | undefined {
      return this.report;
  }

  /**
  * Gets the current value of field report if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getReportOrElse(defaultValue: Reference[]): Reference[] {
      if (this.report == undefined || this.report == null ) { return defaultValue; }
      return this.report;
  }

  public addComplication(newValue: CodeableConcept) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.complication) !== 'undefined') {
         delete this.complication;
      }
      return;
    }
    
    if (typeof(this.complication) === 'undefined') {
      this.complication =  [];
    }
    this.complication.push(newValue);
  }
  /**
  * Removes all elements from the array complication, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteComplicationAll(): CodeableConcept[] {
    if (typeof(this.complication) !== 'undefined') {
       const oldArray = this.complication;
       delete this.complication;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array complication, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteComplicationBySplice(start: number, deleteCount?: number): CodeableConcept[] {
    if (typeof(this.complication) !== 'undefined') {
       return this.complication.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field complication.
  * @returns the value  or undefined
  */
  public getComplication(): CodeableConcept[] | undefined {
      return this.complication;
  }

  /**
  * Gets the current value of field complication if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getComplicationOrElse(defaultValue: CodeableConcept[]): CodeableConcept[] {
      if (this.complication == undefined || this.complication == null ) { return defaultValue; }
      return this.complication;
  }

  public addComplicationDetail(newValue: Reference) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.complicationDetail) !== 'undefined') {
         delete this.complicationDetail;
      }
      return;
    }
    
    if (typeof(this.complicationDetail) === 'undefined') {
      this.complicationDetail =  [];
    }
    this.complicationDetail.push(newValue);
  }
  /**
  * Removes all elements from the array complicationDetail, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteComplicationDetailAll(): Reference[] {
    if (typeof(this.complicationDetail) !== 'undefined') {
       const oldArray = this.complicationDetail;
       delete this.complicationDetail;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array complicationDetail, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteComplicationDetailBySplice(start: number, deleteCount?: number): Reference[] {
    if (typeof(this.complicationDetail) !== 'undefined') {
       return this.complicationDetail.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field complicationDetail.
  * @returns the value  or undefined
  */
  public getComplicationDetail(): Reference[] | undefined {
      return this.complicationDetail;
  }

  /**
  * Gets the current value of field complicationDetail if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getComplicationDetailOrElse(defaultValue: Reference[]): Reference[] {
      if (this.complicationDetail == undefined || this.complicationDetail == null ) { return defaultValue; }
      return this.complicationDetail;
  }

  public addFollowUp(newValue: CodeableConcept) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.followUp) !== 'undefined') {
         delete this.followUp;
      }
      return;
    }
    
    if (typeof(this.followUp) === 'undefined') {
      this.followUp =  [];
    }
    this.followUp.push(newValue);
  }
  /**
  * Removes all elements from the array followUp, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteFollowUpAll(): CodeableConcept[] {
    if (typeof(this.followUp) !== 'undefined') {
       const oldArray = this.followUp;
       delete this.followUp;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array followUp, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteFollowUpBySplice(start: number, deleteCount?: number): CodeableConcept[] {
    if (typeof(this.followUp) !== 'undefined') {
       return this.followUp.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field followUp.
  * @returns the value  or undefined
  */
  public getFollowUp(): CodeableConcept[] | undefined {
      return this.followUp;
  }

  /**
  * Gets the current value of field followUp if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getFollowUpOrElse(defaultValue: CodeableConcept[]): CodeableConcept[] {
      if (this.followUp == undefined || this.followUp == null ) { return defaultValue; }
      return this.followUp;
  }

  public addNote(newValue: Annotation) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.note) !== 'undefined') {
         delete this.note;
      }
      return;
    }
    
    if (typeof(this.note) === 'undefined') {
      this.note =  [];
    }
    this.note.push(newValue);
  }
  /**
  * Removes all elements from the array note, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteNoteAll(): Annotation[] {
    if (typeof(this.note) !== 'undefined') {
       const oldArray = this.note;
       delete this.note;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array note, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteNoteBySplice(start: number, deleteCount?: number): Annotation[] {
    if (typeof(this.note) !== 'undefined') {
       return this.note.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field note.
  * @returns the value  or undefined
  */
  public getNote(): Annotation[] | undefined {
      return this.note;
  }

  /**
  * Gets the current value of field note if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getNoteOrElse(defaultValue: Annotation[]): Annotation[] {
      if (this.note == undefined || this.note == null ) { return defaultValue; }
      return this.note;
  }

  public addFocalDevice(newValue: ProcedureFocalDevice) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.focalDevice) !== 'undefined') {
         delete this.focalDevice;
      }
      return;
    }
    
    if (typeof(this.focalDevice) === 'undefined') {
      this.focalDevice =  [];
    }
    this.focalDevice.push(newValue);
  }
  /**
  * Removes all elements from the array focalDevice, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteFocalDeviceAll(): ProcedureFocalDevice[] {
    if (typeof(this.focalDevice) !== 'undefined') {
       const oldArray = this.focalDevice;
       delete this.focalDevice;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array focalDevice, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteFocalDeviceBySplice(start: number, deleteCount?: number): ProcedureFocalDevice[] {
    if (typeof(this.focalDevice) !== 'undefined') {
       return this.focalDevice.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field focalDevice.
  * @returns the value  or undefined
  */
  public getFocalDevice(): ProcedureFocalDevice[] | undefined {
      return this.focalDevice;
  }

  /**
  * Gets the current value of field focalDevice if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getFocalDeviceOrElse(defaultValue: ProcedureFocalDevice[]): ProcedureFocalDevice[] {
      if (this.focalDevice == undefined || this.focalDevice == null ) { return defaultValue; }
      return this.focalDevice;
  }

  public addUsedReference(newValue: Reference) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.usedReference) !== 'undefined') {
         delete this.usedReference;
      }
      return;
    }
    
    if (typeof(this.usedReference) === 'undefined') {
      this.usedReference =  [];
    }
    this.usedReference.push(newValue);
  }
  /**
  * Removes all elements from the array usedReference, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteUsedReferenceAll(): Reference[] {
    if (typeof(this.usedReference) !== 'undefined') {
       const oldArray = this.usedReference;
       delete this.usedReference;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array usedReference, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteUsedReferenceBySplice(start: number, deleteCount?: number): Reference[] {
    if (typeof(this.usedReference) !== 'undefined') {
       return this.usedReference.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field usedReference.
  * @returns the value  or undefined
  */
  public getUsedReference(): Reference[] | undefined {
      return this.usedReference;
  }

  /**
  * Gets the current value of field usedReference if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getUsedReferenceOrElse(defaultValue: Reference[]): Reference[] {
      if (this.usedReference == undefined || this.usedReference == null ) { return defaultValue; }
      return this.usedReference;
  }

  public addUsedCode(newValue: CodeableConcept) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.usedCode) !== 'undefined') {
         delete this.usedCode;
      }
      return;
    }
    
    if (typeof(this.usedCode) === 'undefined') {
      this.usedCode =  [];
    }
    this.usedCode.push(newValue);
  }
  /**
  * Removes all elements from the array usedCode, returning the deleted elements.
  * @returns An array containing the elements that were deleted.
  */
  public deleteUsedCodeAll(): CodeableConcept[] {
    if (typeof(this.usedCode) !== 'undefined') {
       const oldArray = this.usedCode;
       delete this.usedCode;
       return oldArray;
    }
    return [];
  }
  
  /**
  * Removes elements from the array usedCode, returning the deleted elements.
  * @param start The zero-based location in the array from which to start removing elements.
  * @param deleteCount The number of elements to remove.
  * @returns An array containing the elements that were deleted, or an empty array if the element
  *     was undefined.
  */
  public deleteUsedCodeBySplice(start: number, deleteCount?: number): CodeableConcept[] {
    if (typeof(this.usedCode) !== 'undefined') {
       return this.usedCode.splice(start, deleteCount);
    }
    return [];
  }
  
  /**
  * Gets the current value of field usedCode.
  * @returns the value  or undefined
  */
  public getUsedCode(): CodeableConcept[] | undefined {
      return this.usedCode;
  }

  /**
  * Gets the current value of field usedCode if it exists,
  * but if it is 'undefined' it will return the value supplied
  * as the parameter.
  * @returns the value or the parameter value
  */
  public getUsedCodeOrElse(defaultValue: CodeableConcept[]): CodeableConcept[] {
      if (this.usedCode == undefined || this.usedCode == null ) { return defaultValue; }
      return this.usedCode;
  }


}


