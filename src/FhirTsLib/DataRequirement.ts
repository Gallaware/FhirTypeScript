import { Type } from 'class-transformer';
import { REGEX_ID, REGEX_TYPE } from '../FhirTsLibValidation/FhirRegex';
import { CodeableConcept, DataRequirementCodeFilter, DataRequirementDateFilter, DataRequirementSort, Element, Extension, Reference } from './FhirType';



/**
 * Describes a required data item for evaluation in terms of the type of data, and optional code or
 * date-based filters of the data.
 *
 * Generated by Gallaware, Inc. from:
 *    file:/Users/admin/Documents/DevNetbeans/jsonSchemaToJava/target/classes/schema/fhir.schema.json#/definitions/DataRequirement
 */
export class DataRequirement {
  /**
   * A sequence of Unicode characters
   * Field access restricted because there are specific valid values.
   */
  protected id?: string;

  /**
   * May be used to represent additional information that is not part of the basic definition of the
   * element. To make the use of extensions safe and manageable, there is a strict set of governance
   * applied to the definition and use of extensions. Though any implementer can define an extension,
   * there is a set of requirements that SHALL be met as part of the definition of the extension.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Extension)
  protected extension?: Extension[];

  /**
   * A string which has at least one character and no leading or trailing whitespace and where there is
   * no whitespace other than single spaces in the contents
   * Field access restricted because there are specific valid values.
   */
  protected type?: string;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _type?: Element;

  /**
   * The profile of the required data, specified as the uri of the profile definition.
   * Field access restricted because there are specific valid values.
   */
  protected profile?: string[];

  /**
   * A concept that may be defined by a formal reference to a terminology or ontology or may be provided
   * by text.
   */
  @Type(() => CodeableConcept)
   subjectCodeableConcept?: CodeableConcept;

  /**
   * A reference from one resource to another.
   */
  @Type(() => Reference)
   subjectReference?: Reference;

  /**
   * Indicates that specific elements of the type are referenced by the knowledge module and must be
   * supported by the consumer in order to obtain an effective evaluation. This does not mean that a
   * value is required for this element, only that the consuming system must understand the element and
   * be able to provide values for it if they are available.
   * 
   * The value of mustSupport SHALL be a FHIRPath resolveable on the type of the DataRequirement. The
   * path SHALL consist only of identifiers, constant indexers, and .resolve() (see the [Simple
   * FHIRPath Profile](fhirpath.html#simple) for full details).
   * Field access restricted because there are specific valid values.
   */
  protected mustSupport?: string[];

  /**
   * Extensions for mustSupport
   * Field access restricted because there are specific valid values.
   */
  @Type(() => Element)
  protected _mustSupport?: Element[];

  /**
   * Code filters specify additional constraints on the data, specifying the value set of interest for a
   * particular element of the data. Each code filter defines an additional constraint on the data, i.e.
   * code filters are AND'ed, not OR'ed.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => DataRequirementCodeFilter)
  protected codeFilter?: DataRequirementCodeFilter[];

  /**
   * Date filters specify additional constraints on the data in terms of the applicable date range for
   * specific elements. Each date filter specifies an additional constraint on the data, i.e. date
   * filters are AND'ed, not OR'ed.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => DataRequirementDateFilter)
  protected dateFilter?: DataRequirementDateFilter[];

  /**
   * An integer with a value that is positive (e.g. >0)
   */
   limit?: number;

  /**
   * Base definition for all elements in a resource.
   */
  @Type(() => Element)
   _limit?: Element;

  /**
   * Specifies the order of the results to be returned.
   * Field access restricted because there are specific valid values.
   */
  @Type(() => DataRequirementSort)
  protected sort?: DataRequirementSort[];


  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setId(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.id) !== 'undefined') {
         delete this.id;
      }
      return;
    }
    
    if (REGEX_ID.test(newValue)) {
      this.id = newValue
    } else {
      throw new Error("Invalid value pattern for id of " + newValue);
    }
  }
  
  public getIdPattern(): string {
    return REGEX_ID.source;
  }
  

  public getId(): string | undefined {
      return this.id;
  }

  public addExtension(newValue: Extension) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.extension) !== 'undefined') {
         delete this.extension;
      }
      return;
    }
    
    if (typeof(this.extension) === 'undefined') {
      this.extension =  [];
    }
    this.extension.push(newValue);
  }

  public getExtension(): Extension[] | undefined {
      return this.extension;
  }

  /*
  * This sets the data ensuring that the value is valid pattern.  If not valid, it throws an error
  * that should be caught.
  */
  public setType(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.type) !== 'undefined') {
         delete this.type;
      }
      return;
    }
    
    if (REGEX_TYPE.test(newValue)) {
      this.type = newValue
    } else {
      throw new Error("Invalid value pattern for type of " + newValue);
    }
  }
  
  public getTypePattern(): string {
    return REGEX_TYPE.source;
  }
  

  public getType(): string | undefined {
      return this.type;
  }

  public addProfile(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.profile) !== 'undefined') {
         delete this.profile;
      }
      return;
    }
    
    if (typeof(this.profile) === 'undefined') {
      this.profile =  [];
    }
    this.profile.push(newValue);
  }

  public getProfile(): string[] | undefined {
      return this.profile;
  }

  public addMustSupport(newValue: string) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.mustSupport) !== 'undefined') {
         delete this.mustSupport;
      }
      return;
    }
    
    if (typeof(this.mustSupport) === 'undefined') {
      this.mustSupport =  [];
    }
    this.mustSupport.push(newValue);
  }

  public getMustSupport(): string[] | undefined {
      return this.mustSupport;
  }

  public add_mustSupport(newValue: Element) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this._mustSupport) !== 'undefined') {
         delete this._mustSupport;
      }
      return;
    }
    
    if (typeof(this._mustSupport) === 'undefined') {
      this._mustSupport =  [];
    }
    this._mustSupport.push(newValue);
  }

  public get_mustSupport(): Element[] | undefined {
      return this._mustSupport;
  }

  public addCodeFilter(newValue: DataRequirementCodeFilter) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.codeFilter) !== 'undefined') {
         delete this.codeFilter;
      }
      return;
    }
    
    if (typeof(this.codeFilter) === 'undefined') {
      this.codeFilter =  [];
    }
    this.codeFilter.push(newValue);
  }

  public getCodeFilter(): DataRequirementCodeFilter[] | undefined {
      return this.codeFilter;
  }

  public addDateFilter(newValue: DataRequirementDateFilter) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.dateFilter) !== 'undefined') {
         delete this.dateFilter;
      }
      return;
    }
    
    if (typeof(this.dateFilter) === 'undefined') {
      this.dateFilter =  [];
    }
    this.dateFilter.push(newValue);
  }

  public getDateFilter(): DataRequirementDateFilter[] | undefined {
      return this.dateFilter;
  }

  public addSort(newValue: DataRequirementSort) {
    if (typeof(newValue) === 'undefined') {
      if (typeof(this.sort) !== 'undefined') {
         delete this.sort;
      }
      return;
    }
    
    if (typeof(this.sort) === 'undefined') {
      this.sort =  [];
    }
    this.sort.push(newValue);
  }

  public getSort(): DataRequirementSort[] | undefined {
      return this.sort;
  }


}


